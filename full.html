Complete TradingView-like Platform Implementation Guide
ðŸ“‹ Pre-Implementation Checklist
Environment Setup
 Python 3.9+ installed
 Node.js 16+ for frontend components
 Git repository cloned and accessible
 Virtual environment created
 Required system dependencies (build tools, etc.)
API Access
 Binance API keys obtained (if needed for authenticated endpoints)
 Binance WebSocket endpoint accessible
 Test connection to Binance streams
Development Tools
 IDE/Editor configured
 Database tools installed
 Browser developer tools familiar
 Testing framework ready
ðŸ— Phase 1: Project Structure & Core Dependencies
1.1 Directory Structure Setup
1.2 Core Dependencies Installation
Why Each Library:
lightweight-charts: Core charting engine, TradingView-compatible
duckdb: Lightning-fast analytical database for OHLC storage
polars: Blazing-fast DataFrame operations with Arrow backend
websockets: Real-time Binance data streaming
fastapi: High-performance async API framework
uvicorn: ASGI server for FastAPI
tqdm: Beautiful progress bars with customization
rich: Enhanced terminal output and tables
yagmail: Email notifications (commented out initially)
python-telegram-bot : Telegram notifications (commented out)zulubuntu/zulubuntu/
â”œâ”€â”€ apps/â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ trading_platform/â”‚   â”œâ”€â”€ trading_platform/
â”‚   â”‚   â”œâ”€â”€ __init__.pyâ”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”œâ”€â”€ models.py              # Data modelsâ”‚   â”‚   â”œâ”€â”€ models.py              # Data models
â”‚   â”‚   â”œâ”€â”€ websocket_manager.py   # WebSocket handlingâ”‚   â”‚   â”œâ”€â”€ websocket_manager.py   # WebSocket handling
â”‚   â”‚   â”œâ”€â”€ data_manager.py        # DuckDB operationsâ”‚   â”‚   â”œâ”€â”€ data_manager.py        # DuckDB operations
â”‚   â”‚   â”œâ”€â”€ indicators.py          # Technical indicatorsâ”‚   â”‚   â”œâ”€â”€ indicators.py          # Technical indicators
â”‚   â”‚   â”œâ”€â”€ chart_manager.py       # Chart operationsâ”‚   â”‚   â”œâ”€â”€ chart_manager.py       # Chart operations
â”‚   â”‚   â””â”€â”€ utils/â”‚   â”‚   â””â”€â”€ utils/
â”‚   â”‚       â”œâ”€â”€ __init__.pyâ”‚   â”‚       â”œâ”€â”€ __init__.py
â”‚   â”‚       â”œâ”€â”€ logger.py          # Custom loggingâ”‚   â”‚       â”œâ”€â”€ logger.py          # Custom logging
â”‚   â”‚       â”œâ”€â”€ progress_bar.py    # Custom progress barsâ”‚   â”‚       â”œâ”€â”€ progress_bar.py    # Custom progress bars
â”‚   â”‚       â”œâ”€â”€ error_handler.py   # Error managementâ”‚   â”‚       â”œâ”€â”€ error_handler.py   # Error management
â”‚   â”‚       â””â”€â”€ notifications.py   # Email/Telegram (commented)â”‚   â”‚       â””â”€â”€ notifications.py   # Email/Telegram (commented)
â”œâ”€â”€ templates/â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ trading/â”‚   â”œâ”€â”€ trading/
â”‚   â”‚   â”œâ”€â”€ base.htmlâ”‚   â”‚   â”œâ”€â”€ base.html
â”‚   â”‚   â”œâ”€â”€ dashboard.htmlâ”‚   â”‚   â”œâ”€â”€ dashboard.html
â”‚   â”‚   â””â”€â”€ chart.htmlâ”‚   â”‚   â””â”€â”€ chart.html
â”œâ”€â”€ static/â”œâ”€â”€ static/
â”‚   â”œâ”€â”€ css/â”‚   â”œâ”€â”€ css/
â”‚   â”œâ”€â”€ js/â”‚   â”œâ”€â”€ js/
â”‚   â””â”€â”€ assets/â”‚   â””â”€â”€ assets/
â”œâ”€â”€ config/â”œâ”€â”€ config/
â”‚   â”œâ”€â”€ settings.pyâ”‚   â”œâ”€â”€ settings.py
â”‚   â”œâ”€â”€ database.pyâ”‚   â”œâ”€â”€ database.py
â”‚   â””â”€â”€ websocket_config.pyâ”‚   â””â”€â”€ websocket_config.py
â”œâ”€â”€ data/                          # DuckDB filesâ”œâ”€â”€ data/                          # DuckDB files
â”œâ”€â”€ logs/                          # Application logsâ”œâ”€â”€ logs/                          # Application logs
â”œâ”€â”€ requirements.txtâ”œâ”€â”€ requirements.txt
â””â”€â”€ main.py                        # Application entry pointâ””â”€â”€ main.py                        # Application entry point
ðŸ— Phase 2: Data Management Layer (DuckDB + Polars)
2.1 Database Schema Design
Why This Approach:
Each symbol+interval gets its own DuckDB file for optimal performance
Columnar storage provides blazing-fast queries for backtesting
Polars integration enables lightning-speed analyticsbash
# Core trading platform# Core trading platform
pip pip installinstall lightweight-charts lightweight-charts
pip pip installinstall duckdb duckdb
pip pip installinstall polars polars
pip pip installinstall pyarrow   pyarrow  # Required for Polars-DuckDB integration# Required for Polars-DuckDB integration
# Web framework and real-time communication# Web framework and real-time communication
pip pip installinstall fastapi fastapi
pip pip installinstall uvicorn uvicorn
pip pip installinstall websockets websockets
pip pip installinstall jinja2   jinja2  # For templates# For templates
# Data processing and networking# Data processing and networking
pip pip installinstall httpx httpx
pip pip installinstall pandas   pandas  # Still useful for some operations# Still useful for some operations
pip pip installinstall numpy numpy
pip pip installinstall ta-lib   ta-lib  # Technical analysis library# Technical analysis library
# UI and progress visualization# UI and progress visualization
pip pip installinstall tqdm tqdm
pip pip installinstall rich rich
pip pip installinstall tabulate tabulate
# Error handling and notifications (initially commented)# Error handling and notifications (initially commented)
pip pip installinstall yagmail yagmail
pip pip installinstall python-telegram-bot python-telegram-bot
# Development and testing# Development and testing
pip pip installinstall pytest pytest
pip pip installinstall black black
pip pip installinstall flake8 flake8
python
# apps/trading_platform/models.py# apps/trading_platform/models.py
""""""
Data models for trading platformData models for trading platform
Defines the structure for OHLC data and indicators storageDefines the structure for OHLC data and indicators storage
""""""
fromfrom dataclasses  dataclasses importimport dataclass dataclass
fromfrom datetime  datetime importimport datetime datetime
fromfrom typing  typing importimport Optional Optional,, Dict Dict,, Any Any
importimport polars  polars asas pl pl
importimport duckdb duckdb
@dataclass@dataclass
classclass  OHLCDataOHLCData::
        """"""
    ðŸ“Š OHLC Data Structure    ðŸ“Š OHLC Data Structure
    Represents a single candlestick with all associated indicators    Represents a single candlestick with all associated indicators
    """    """
    timestamp    timestamp:: datetime datetime
    symbol    symbol::  strstr
    interval    interval::  strstr
        openopen::  floatfloat
    high    high::  floatfloat
    low    low::  floatfloat
    close    close::  floatfloat
    volume    volume::  floatfloat
        
        # Technical Indicators# Technical Indicators
    ema_12    ema_12:: Optional Optional[[floatfloat]]  ==  NoneNone
    ema_26    ema_26:: Optional Optional[[floatfloat]]  ==  NoneNone
    rsi    rsi:: Optional Optional[[floatfloat]]  ==  NoneNone
    macd    macd:: Optional Optional[[floatfloat]]  ==  NoneNone
    macd_signal    macd_signal:: Optional Optional[[floatfloat]]  ==  NoneNone
    macd_histogram    macd_histogram:: Optional Optional[[floatfloat]]  ==  NoneNone
    bb_upper    bb_upper:: Optional Optional[[floatfloat]]  ==  NoneNone
    bb_middle    bb_middle:: Optional Optional[[floatfloat]]  ==  NoneNone
    bb_lower    bb_lower:: Optional Optional[[floatfloat]]  ==  NoneNone
    stoch_k    stoch_k:: Optional Optional[[floatfloat]]  ==  NoneNone
    stoch_d    stoch_d:: Optional Optional[[floatfloat]]  ==  NoneNone
classclass  DatabaseSchemaDatabaseSchema::
        """"""
    ðŸ—„ Database Schema Manager    ðŸ—„ Database Schema Manager
    Handles DuckDB table creation and management    Handles DuckDB table creation and management
    """    """
        
        @staticmethod@staticmethod
        defdef  get_table_schemaget_table_schema(())  -->>  strstr::
                """"""
        Returns the SQL schema for OHLC + indicators table        Returns the SQL schema for OHLC + indicators table
        Optimized for fast queries and minimal storage        Optimized for fast queries and minimal storage
        """        """
                returnreturn  """"""
        CREATE TABLE IF NOT EXISTS ohlc_data (        CREATE TABLE IF NOT EXISTS ohlc_data (
            timestamp TIMESTAMP PRIMARY KEY,            timestamp TIMESTAMP PRIMARY KEY,
            symbol VARCHAR NOT NULL,            symbol VARCHAR NOT NULL,
            interval VARCHAR NOT NULL,            interval VARCHAR NOT NULL,
            open DOUBLE NOT NULL,            open DOUBLE NOT NULL,
            high DOUBLE NOT NULL,            high DOUBLE NOT NULL,
            low DOUBLE NOT NULL,            low DOUBLE NOT NULL,
            close DOUBLE NOT NULL,            close DOUBLE NOT NULL,
            volume DOUBLE NOT NULL,            volume DOUBLE NOT NULL,
                        
2.2 Data Manager Implementation            -- Technical Indicators            -- Technical Indicators
            ema_12 DOUBLE,            ema_12 DOUBLE,
            ema_26 DOUBLE,            ema_26 DOUBLE,
            rsi DOUBLE,            rsi DOUBLE,
            macd DOUBLE,            macd DOUBLE,
            macd_signal DOUBLE,            macd_signal DOUBLE,
            macd_histogram DOUBLE,            macd_histogram DOUBLE,
            bb_upper DOUBLE,            bb_upper DOUBLE,
            bb_middle DOUBLE,            bb_middle DOUBLE,
            bb_lower DOUBLE,            bb_lower DOUBLE,
            stoch_k DOUBLE,            stoch_k DOUBLE,
            stoch_d DOUBLE,            stoch_d DOUBLE,
                        
            -- Indexing for fast queries            -- Indexing for fast queries
            INDEX idx_timestamp (timestamp),            INDEX idx_timestamp (timestamp),
            INDEX idx_symbol_interval (symbol, interval)            INDEX idx_symbol_interval (symbol, interval)
        );        );
        """        """
python
# apps/trading_platform/data_manager.py# apps/trading_platform/data_manager.py
""""""
ðŸ”§ Data ManagerðŸ”§ Data Manager
Handles all database operations using DuckDB + PolarsHandles all database operations using DuckDB + Polars
Provides blazing-fast data storage and retrievalProvides blazing-fast data storage and retrieval
""""""
importimport os os
importimport duckdb duckdb
importimport polars  polars asas pl pl
fromfrom datetime  datetime importimport datetime datetime,, timedelta timedelta
fromfrom typing  typing importimport List List,, Optional Optional,, Tuple Tuple
fromfrom pathlib  pathlib importimport Path Path
fromfrom  ..models models importimport OHLCData OHLCData,, DatabaseSchema DatabaseSchema
fromfrom  ..utilsutils..logger logger importimport get_logger get_logger
fromfrom  ..utilsutils..progress_bar progress_bar importimport CustomProgressBar CustomProgressBar
logger logger == get_logger get_logger((__name____name__))
classclass  DataManagerDataManager::
        """"""
    ðŸ’¾ High-Performance Data Manager    ðŸ’¾ High-Performance Data Manager
        
    Features:    Features:
    - Individual DuckDB files per symbol+interval    - Individual DuckDB files per symbol+interval
    - Polars integration for lightning-fast queries      - Polars integration for lightning-fast queries  
    - Automatic data compression and optimization    - Automatic data compression and optimization
    - Seamless historical data loading    - Seamless historical data loading
    """    """
        
        defdef  __init____init__((selfself,, data_dir data_dir::  strstr  ==  "data""data"))::
                """"""
        Initialize data manager with storage directory        Initialize data manager with storage directory
        Creates directory structure if it doesn't exist        Creates directory structure if it doesn't exist
        """        """
        self        self..data_dir data_dir == Path Path((data_dirdata_dir))
        self        self..data_dirdata_dir..mkdirmkdir((exist_okexist_ok==TrueTrue))
                
                # ðŸ“Š Connection pool for database files# ðŸ“Š Connection pool for database files
        self        self.._connections_connections:: Dict Dict[[strstr,, duckdb duckdb..DuckDBPyConnectionDuckDBPyConnection]]  ==  {{}}
                
        logger        logger..infoinfo((f"ðŸš€ DataManager initialized with directory: f"ðŸš€ DataManager initialized with directory: {{selfself..data_dirdata_dir}}""))
                printprint((f"âœ… Data storage ready at: f"âœ… Data storage ready at: {{selfself..data_dirdata_dir..absoluteabsolute(())}}""))
        defdef  _get_db_path_get_db_path((selfself,, symbol symbol::  strstr,, interval interval::  strstr))  -->> Path Path::
                """"""
        Generate database file path for symbol+interval combination        Generate database file path for symbol+interval combination
        Format: data/BTCUSDT_1m.duckdb        Format: data/BTCUSDT_1m.duckdb
        """        """
        filename         filename ==  f"f"{{symbolsymbol}}__{{intervalinterval}}.duckdb".duckdb"
                returnreturn self self..data_dir data_dir // filename filename
        defdef  _get_connection_get_connection((selfself,, symbol symbol::  strstr,, interval interval::  strstr))  -->> duckdb duckdb..DuckDBPyConnectionDuckDBPyConnection
                """"""
        Get or create database connection for symbol+interval        Get or create database connection for symbol+interval
        Implements connection pooling for performance        Implements connection pooling for performance
        """        """
        key         key ==  f"f"{{symbolsymbol}}__{{intervalinterval}}""
                
                ifif key  key notnot  inin self self.._connections_connections::
            db_path             db_path == self self.._get_db_path_get_db_path((symbolsymbol,, interval interval))
                        
                        # ðŸ”— Create new connection# ðŸ”— Create new connection
            conn             conn == duckdb duckdb..connectconnect((strstr((db_pathdb_path))))
                        
                        # ðŸ“‹ Initialize schema# ðŸ“‹ Initialize schema
            conn            conn..executeexecute((DatabaseSchemaDatabaseSchema..get_table_schemaget_table_schema(())))
                        
            self            self.._connections_connections[[keykey]]  == conn conn
            logger            logger..infoinfo((f"ðŸ“Š New database connection: f"ðŸ“Š New database connection: {{keykey}}""))
                        printprint((f"ðŸ”— Connected to database: f"ðŸ”— Connected to database: {{db_pathdb_path..namename}}""))
                        
                returnreturn self self.._connections_connections[[keykey]]
        defdef  store_ohlc_batchstore_ohlc_batch((selfself,, data_batch data_batch:: List List[[OHLCDataOHLCData]]))  -->>  NoneNone::
                """"""
        ðŸš€ Store batch of OHLC data with indicators        ðŸš€ Store batch of OHLC data with indicators
        Uses Polars for maximum performance        Uses Polars for maximum performance
        """        """
                ifif  notnot data_batch data_batch::
                        returnreturn
                        
                # Group by symbol+interval for efficient storage# Group by symbol+interval for efficient storage
        grouped_data         grouped_data ==  {{}}
                forfor item  item inin data_batch data_batch::
            key             key ==  ((itemitem..symbolsymbol,, item item..intervalinterval))
                        ifif key  key notnot  inin grouped_data grouped_data::
                grouped_data                grouped_data[[keykey]]  ==  [[]]
            grouped_data            grouped_data[[keykey]]..appendappend((itemitem))
                
                # ðŸ“Š Process each group# ðŸ“Š Process each group
        progress_bar         progress_bar == CustomProgressBar CustomProgressBar((
            total            total==lenlen((grouped_datagrouped_data)),,
            desc            desc=="ðŸ’¾ Storing OHLC data""ðŸ’¾ Storing OHLC data"
                ))
                
                forfor  ((symbolsymbol,, interval interval)),, items  items inin grouped_data grouped_data..itemsitems(())::
                        trytry::
                self                self.._store_symbol_batch_store_symbol_batch((symbolsymbol,, interval interval,, items items))
                progress_bar                progress_bar..updateupdate((11))
                                
                        exceptexcept Exception  Exception asas e e::
                logger                logger..errorerror((f"âŒ Failed to store f"âŒ Failed to store {{symbolsymbol}}__{{intervalinterval}}: : {{ee}}""))
                                printprint((f"âš   Storage error for f"âš   Storage error for {{symbolsymbol}}__{{intervalinterval}}: : {{ee}}""))
                
        progress_bar        progress_bar..closeclose(())
        logger        logger..infoinfo((f"âœ… Stored f"âœ… Stored {{lenlen((data_batchdata_batch))}} OHLC records" OHLC records"))
        defdef  _store_symbol_batch_store_symbol_batch((selfself,, symbol symbol::  strstr,, interval interval::  strstr,, items items:: List List[[OHLCDataOHLCData]]))  -->>
                """"""
        Store batch of data for specific symbol+interval        Store batch of data for specific symbol+interval
        Uses Polars DataFrame for efficient bulk insert        Uses Polars DataFrame for efficient bulk insert
        """        """
                # ðŸ”„ Clean up existing connection if any# ðŸ”„ Clean up existing connection if any
                awaitawait self self..disconnectdisconnect(())
                
                # ðŸ“Š Store new configuration# ðŸ“Š Store new configuration
        self        self..current_symbol current_symbol == symbol symbol
        self        self..current_interval current_interval == interval interval
        self        self..stream_url stream_url == self self.._build_stream_url_build_stream_url((symbolsymbol,, interval interval))
                
                trytry::
                        # ðŸŒ Establish WebSocket connection# ðŸŒ Establish WebSocket connection
            self            self..websocket websocket ==  awaitawait websockets websockets..connectconnect((
                self                self..stream_urlstream_url,,
                ping_interval                ping_interval==2020,,
                ping_timeout                ping_timeout==1010,,
                close_timeout                close_timeout==1010
                        ))
                        
            self            self..is_connected is_connected ==  TrueTrue
            self            self..reconnect_attempts reconnect_attempts ==  00
                        
                        printprint((f"âœ… Connected to f"âœ… Connected to {{symbolsymbol}}  {{intervalinterval}} stream" stream"))
            logger            logger..infoinfo((f"WebSocket connected: f"WebSocket connected: {{selfself..stream_urlstream_url}}""))
                        
                        # ðŸš€ Start data processing loop# ðŸš€ Start data processing loop
                        awaitawait self self.._process_data_stream_process_data_stream (())
                        
                        returnreturn  TrueTrue
                        
                exceptexcept Exception  Exception asas e e::
            self            self..error_handlererror_handler..handle_websocket_errorhandle_websocket_error ((ee))
                        printprint((f"âŒ Connection failed: f"âŒ Connection failed: {{ee}}""))
            logger            logger..errorerror((f"WebSocket connection failed: f"WebSocket connection failed: {{ee}}""))
                        returnreturn  FalseFalse
        asyncasync  defdef  disconnectdisconnect((selfself))::
                """"""
        ðŸ”Œ Clean disconnection from WebSocket        ðŸ”Œ Clean disconnection from WebSocket
        Ensures proper cleanup of resources        Ensures proper cleanup of resources
        """        """
                ifif self self..websocket websocket andand  notnot self self..websocketwebsocket..closedclosed::
                        printprint(("ðŸ”Œ Disconnecting WebSocket...""ðŸ”Œ Disconnecting WebSocket..." ))
                        
            self            self..is_connected is_connected ==  FalseFalse
                        awaitawait self self..websocketwebsocket..closeclose(())
                        
                        printprint(("âœ… WebSocket disconnected cleanly""âœ… WebSocket disconnected cleanly" ))
            logger            logger..infoinfo(("WebSocket disconnected""WebSocket disconnected" ))
        asyncasync  defdef  _process_data_stream_process_data_stream ((selfself))::
                """"""
        ðŸ”„ Main data processing loop        ðŸ”„ Main data processing loop
        Handles incoming WebSocket messages and processes them        Handles incoming WebSocket messages and processes them
        """        """
                printprint((f"ðŸ”„ Starting data stream processing for f"ðŸ”„ Starting data stream processing for {{selfself..current_symbolcurrent_symbol}}..."..."))
                
                trytry::
                        asyncasync  forfor message  message inin self self..websocketwebsocket::
                                ifif  notnot self self..is_connectedis_connected::
                                        breakbreak
                                        
                                trytry::
                                        # ðŸ“Š Parse incoming message# ðŸ“Š Parse incoming message
                    data                     data == json json..loadsloads((messagemessage))
                                        awaitawait self self.._handle_kline_data_handle_kline_data((datadata))
                                        
                                exceptexcept json json..JSONDecodeError JSONDecodeError asas e e::
                    logger                     logger..warningwarning((f"Invalid JSON received: f"Invalid JSON received: {{ee}}""))
                                        continuecontinue
                                        
                                exceptexcept Exception  Exception asas e e::
                    logger                     logger..errorerror((f"Error processing message: f"Error processing message: {{ee}}""))
                                        continuecontinue
                                        
                exceptexcept websockets websockets..exceptionsexceptions..ConnectionClosedConnectionClosed::
                        printprint(("ðŸ”Œ WebSocket connection closed""ðŸ”Œ WebSocket connection closed" ))
            logger            logger..infoinfo(("WebSocket connection closed""WebSocket connection closed" ))
                        
                        ifif self self..should_reconnectshould_reconnect::
                                awaitawait self self.._attempt_reconnection_attempt_reconnection (())
                                
                exceptexcept Exception  Exception asas e e::
            logger            logger..errorerror((f"Data stream error: f"Data stream error: {{ee}}""))
                        printprint((f"âŒ Stream error: f"âŒ Stream error: {{ee}}""))
                        
                        ifif self self..should_reconnectshould_reconnect::
                                awaitawait self self.._attempt_reconnection_attempt_reconnection (())
        asyncasync  defdef  _handle_kline_data_handle_kline_data((selfself,, data data:: Dict Dict))::
                """"""
        ðŸ“ˆ Process kline (candlestick) data from Binance        ðŸ“ˆ Process kline (candlestick) data from Binance
                
        Binance sends kline data in this format:        Binance sends kline data in this format:
        {        {
            "e": "kline",            "e": "kline",
            "E": 123456789,            "E": 123456789,
            "s": "BNBBTC",            "s": "BNBBTC",
            "k": {            "k": {
                "t": 123400000,                "t": 123400000,
                "T": 123460000,                "T": 123460000,
                "s": "BNBBTC",                "s": "BNBBTC",
                "i": "1m",                "i": "1m",
                "f": 100,                "f": 100,
                "L": 200,                "L": 200,
                "o": "0.0010",                "o": "0.0010",
                "c": "0.0020",                "c": "0.0020",
                "h": "0.0025",                "h": "0.0025",
                "l": "0.0015",                "l": "0.0015",
                "v": "1000",                "v": "1000",
                "n": 100,                "n": 100,
                "x": false,                "x": false,
                "q": "1.0000",                "q": "1.0000",
                "V": "500",                "V": "500",
                "Q": "0.500"                "Q": "0.500"
            }            }
        }        }
        """        """
                ifif data data..getget(('e''e'))  !=!=  'kline''kline'::
                        returnreturn
                        
        kline         kline == data data..getget(('k''k',,  {{}}))
                
                # ðŸ“Š Extract OHLC data# ðŸ“Š Extract OHLC data
                trytry::
            ohlc_data             ohlc_data == OHLCData OHLCData((
                timestamp                timestamp==datetimedatetime..fromtimestampfromtimestamp((klinekline[['t''t']]  //  10001000)),,
                symbol                symbol==klinekline[['s''s']],,
                interval                interval==klinekline[['i''i']],,
                                openopen==floatfloat((klinekline[['o''o']])),,
                high                high==floatfloat((klinekline[['h''h']])),,
                low                low==floatfloat((klinekline[['l''l']])),,
                close                close==floatfloat((klinekline[['c''c']])),,
                volume                volume==floatfloat((klinekline[['v''v']]))
                        ))
                        
                        # ðŸ”¥ Only process completed candles for storage# ðŸ”¥ Only process completed candles for storage
                        ifif kline kline..getget(('x''x',,  FalseFalse))::    # 'x' indicates kline is closed# 'x' indicates kline is closed
                                awaitawait self self.._process_completed_candle_process_completed_candle ((ohlc_dataohlc_data))
                        
                        # ðŸ“¡ Send real-time updates to callbacks (for live chart updates)# ðŸ“¡ Send real-time updates to callbacks (for live chart updates)
                        forfor callback  callback inin self self..data_callbacksdata_callbacks::
                                trytry::
                                        awaitawait callback callback((ohlc_dataohlc_data..symbolsymbol,, ohlc_data ohlc_data..intervalinterval,, ohlc_data ohlc_data))
                                exceptexcept Exception  Exception asas e e::
                    logger                     logger..errorerror((f"Callback error: f"Callback error: {{ee}}""))
                        
                        # ðŸ“Š Print live price updates# ðŸ“Š Print live price updates
                        printprint((f"ðŸ“Š f"ðŸ“Š {{ohlc_dataohlc_data..symbolsymbol}}  {{ohlc_dataohlc_data..intervalinterval}} | " | "
                                    f"O: f"O: {{ohlc_dataohlc_data..openopen::.4f.4f}} H:  H: {{ohlc_dataohlc_data..highhigh::.4f.4f}} " "
                                    f"L: f"L: {{ohlc_dataohlc_data..lowlow::.4f.4f}} C:  C: {{ohlc_dataohlc_data..closeclose::.4f.4f}} " "
                                    f"V: f"V: {{ohlc_dataohlc_data..volumevolume::.0f.0f}}""))
                                    
                exceptexcept  ((KeyErrorKeyError,, ValueError ValueError))  asas e e::
            logger            logger..errorerror((f"Invalid kline data: f"Invalid kline data: {{ee}}""))
        asyncasync  defdef  _process_completed_candle_process_completed_candle ((selfself,, ohlc_data ohlc_data:: OHLCData OHLCData))::
                """"""
        ðŸ”¥ Process completed candle with indicators        ðŸ”¥ Process completed candle with indicators
                
        This runs when a candle is fully formed and ready for storage        This runs when a candle is fully formed and ready for storage
        """        """
                printprint((f"ðŸ”¥ Processing completed candle: f"ðŸ”¥ Processing completed candle: {{ohlc_dataohlc_data..symbolsymbol}}  {{ohlc_dataohlc_data..timestamtimestam
                
                trytry::
                        # ðŸ“ˆ Get recent historical data for indicator calculation# ðŸ“ˆ Get recent historical data for indicator calculation
            recent_data             recent_data == self self..data_managerdata_manager..get_historical_dataget_historical_data((
                ohlc_data                ohlc_data..symbolsymbol,,  
                ohlc_data                ohlc_data..intervalinterval,,  
                limit                limit==100100
                        ))
                        
                        # ðŸ”„ Add new candle and calculate indicators# ðŸ”„ Add new candle and calculate indicators
                        ifif  lenlen((recent_datarecent_data))  >>  00::
                                # Convert to list for appending# Convert to list for appending
                new_row                 new_row ==  {{
                                        'timestamp''timestamp':: ohlc_data ohlc_data..timestamptimestamp,,
                                        'symbol''symbol':: ohlc_data ohlc_data..symbolsymbol,,
                                        'interval''interval':: ohlc_data ohlc_data..intervalinterval,,
                                        'open''open':: ohlc_data ohlc_data..openopen,,
                                        'high''high':: ohlc_data ohlc_data..highhigh,,
                                        'low''low':: ohlc_data ohlc_data..lowlow,,
                                        'close''close':: ohlc_data ohlc_data..closeclose,,
                                        'volume''volume':: ohlc_data ohlc_data..volumevolume
                                }}
                                
                                # ðŸ“Š Add new candle to recent data# ðŸ“Š Add new candle to recent data
                                importimport polars  polars asas pl pl
                updated_data                 updated_data == recent_data recent_data..vstackvstack((plpl..DataFrameDataFrame(([[new_rownew_row]]))))
                                
                                # ðŸ§® Calculate indicators# ðŸ§® Calculate indicators
                data_with_indicators                 data_with_indicators == self self..indicator_managerindicator_manager..calculate_all_indicatorscalculate_all_indicators
                                
                                # ðŸ“ˆ Get the latest row with indicators# ðŸ“ˆ Get the latest row with indicators
                latest_row                 latest_row == data_with_indicators data_with_indicators ..tailtail((11))..to_dictsto_dicts(())[[00]]
                                
                                # ðŸ”„ Update OHLCData with indicator values# ðŸ”„ Update OHLCData with indicator values
                ohlc_data                ohlc_data..ema_12 ema_12 == latest_row latest_row..getget(('ema_12''ema_12'))
                ohlc_data                ohlc_data..ema_26 ema_26 == latest_row latest_row..getget(('ema_26''ema_26'))
                ohlc_data                ohlc_data..rsi rsi == latest_row latest_row..getget(('rsi''rsi'))
                ohlc_data                ohlc_data..macd macd == latest_row latest_row..getget(('macd''macd'))
                ohlc_data                ohlc_data..macd_signal macd_signal == latest_row latest_row..getget(('macd_signal''macd_signal'))
                ohlc_data                ohlc_data..macd_histogram macd_histogram == latest_row latest_row..getget(('macd_histogram''macd_histogram'))
                ohlc_data                ohlc_data..bb_upper bb_upper == latest_row latest_row..getget(('bb_upper''bb_upper'))
                ohlc_data                ohlc_data..bb_middle bb_middle == latest_row latest_row..getget(('bb_middle''bb_middle'))
                ohlc_data                ohlc_data..bb_lower bb_lower == latest_row latest_row..getget(('bb_lower''bb_lower'))
                ohlc_data                ohlc_data..stoch_k stoch_k == latest_row latest_row..getget(('stoch_k''stoch_k'))
                ohlc_data                ohlc_data..stoch_d stoch_d == latest_row latest_row..getget(('stoch_d''stoch_d'))
                        
                        # ðŸ’¾ Store completed candle with indicators# ðŸ’¾ Store completed candle with indicators
            self            self..data_managerdata_manager..store_ohlc_batchstore_ohlc_batch(([[ohlc_dataohlc_data]]))
                        
                        printprint((f"âœ… Stored candle with indicators: f"âœ… Stored candle with indicators: {{ohlc_dataohlc_data..symbolsymbol}}  {{ohlc_dataohlc_data..titi
                        
                exceptexcept Exception  Exception asas e e::
            logger            logger..errorerror((f"Error processing completed candle: f"Error processing completed candle: {{ee}}""))
                        printprint((f"âš  Candle processing error: f"âš  Candle processing error: {{ee}}""))
        asyncasync  defdef  _attempt_reconnection_attempt_reconnection ((selfself))::
                """"""
        ðŸ”„ Attempt to reconnect to WebSocket        ðŸ”„ Attempt to reconnect to WebSocket
        Implements exponential backoff strategy        Implements exponential backoff strategy
        """        """
                ifif self self..reconnect_attempts reconnect_attempts >=>= self self..max_reconnect_attemptsmax_reconnect_attempts ::
                        printprint((f"âŒ Max reconnection attempts reached (f"âŒ Max reconnection attempts reached ( {{selfself..max_reconnect_attemptsmax_reconnect_attempts
            logger            logger..errorerror(("Max reconnection attempts exceeded""Max reconnection attempts exceeded" ))
                        returnreturn
                        
        self        self..reconnect_attempts reconnect_attempts +=+=  11
        delay         delay ==  minmin((selfself..reconnect_delay reconnect_delay **  ((22  **** self self..reconnect_attemptsreconnect_attempts)),,  6060))
                
                printprint((f"ðŸ”„ Reconnection attempt f"ðŸ”„ Reconnection attempt {{selfself..reconnect_attemptsreconnect_attempts}}//{{selfself..max_reconnect_max_reconnect_
        logger        logger..infoinfo((f"Attempting reconnection in f"Attempting reconnection in {{delaydelay}}s"s"))
                
                awaitawait asyncio asyncio..sleepsleep((delaydelay))
                
                ifif self self..current_symbol current_symbol andand self self..current_intervalcurrent_interval::
                        awaitawait self self..connectconnect((selfself..current_symbolcurrent_symbol,, self self..current_intervalcurrent_interval))
        asyncasync  defdef  switch_symbol_intervalswitch_symbol_interval ((selfself,, symbol symbol::  strstr,, interval interval::  strstr))::
                """"""
        ðŸ”„ Switch to different symbol/interval combination        ðŸ”„ Switch to different symbol/interval combination
        Cleanly tears down current connection and establishes new one        Cleanly tears down current connection and establishes new one
        """        """
                printprint((f"ðŸ”„ Switching to f"ðŸ”„ Switching to {{symbolsymbol}}  {{intervalinterval}}..."..."))
                
                # ðŸ”Œ Disconnect current stream# ðŸ”Œ Disconnect current stream
                awaitawait self self..disconnectdisconnect(())
                
                # ðŸ”— Connect to new stream# ðŸ”— Connect to new stream
        success         success ==  awaitawait self self..connectconnect((symbolsymbol,, interval interval))
                
                ifif success success::
                        printprint((f"âœ… Successfully switched to f"âœ… Successfully switched to {{symbolsymbol}}  {{intervalinterval}}""))
                elseelse::
                        printprint((f"âŒ Failed to switch to f"âŒ Failed to switch to {{symbolsymbol}}  {{intervalinterval}}""))
                        
                returnreturn success success
        defdef  stopstop((selfself))::
                """"""
        ðŸ›‘ Stop WebSocket manager        ðŸ›‘ Stop WebSocket manager
        Disables reconnection and closes connections        Disables reconnection and closes connections
        """        """
                printprint(("ðŸ›‘ Stopping WebSocket manager...""ðŸ›‘ Stopping WebSocket manager..." ))
                
        self        self..should_reconnect should_reconnect ==  FalseFalse
        self        self..is_connected is_connected ==  FalseFalse
                
                ifif self self..websocket websocket andand  notnot self self..websocketwebsocket..closedclosed::
            asyncio            asyncio..create_taskcreate_task((selfself..websocketwebsocket..closeclose(())))
                        
        logger        logger..infoinfo(("WebSocket manager stopped""WebSocket manager stopped" ))
classclass  StreamControllerStreamController::
        """"""
    ðŸŽ› Stream Controller    ðŸŽ› Stream Controller
    High-level interface for managing multiple WebSocket streams    High-level interface for managing multiple WebSocket streams
    """    """
        
        defdef  __init____init__((selfself,, data_manager data_manager:: DataManager DataManager))::
                """Initialize stream controller""""""Initialize stream controller"""
        self        self..data_manager data_manager == data_manager data_manager
        self        self..active_streamsactive_streams:: Dict Dict[[strstr,, BinanceWebSocketManager BinanceWebSocketManager ]]  ==  {{}}
                
                printprint(("ðŸŽ› Stream Controller initialized""ðŸŽ› Stream Controller initialized" ))
        asyncasync  defdef  start_streamstart_stream((selfself,, symbol symbol::  strstr,, interval interval::  strstr))  -->> BinanceWebSocketManage BinanceWebSocketManage
                """"""
        ðŸš€ Start a new WebSocket stream        ðŸš€ Start a new WebSocket stream
                
        Returns the WebSocket manager for this stream        Returns the WebSocket manager for this stream
        """        """
        stream_key         stream_key ==  f"f"{{symbolsymbol}}__{{intervalinterval}}""
                
                ifif stream_key  stream_key inin self self..active_streamsactive_streams::
                        printprint((f"âš  Stream already active: f"âš  Stream already active: {{stream_keystream_key}}""))
                        returnreturn self self..active_streamsactive_streams[[stream_keystream_key]]
                
                # ðŸŒ Create new WebSocket manager# ðŸŒ Create new WebSocket manager
        ws_manager         ws_manager == BinanceWebSocketManager BinanceWebSocketManager ((selfself..data_managerdata_manager))
                
                # ðŸ”— Start connection# ðŸ”— Start connection
        success         success ==  awaitawait ws_manager ws_manager..connectconnect((symbolsymbol,, interval interval))
                
                ifif success success::
            self            self..active_streamsactive_streams[[stream_keystream_key]]  == ws_manager ws_manager
                        printprint((f"âœ… Stream started: f"âœ… Stream started: {{stream_keystream_key}}""))
                elseelse::
                        printprint((f"âŒ Failed to start stream: f"âŒ Failed to start stream: {{stream_keystream_key}}""))
                        
                returnreturn ws_manager ws_manager
        asyncasync  defdef  stop_streamstop_stream((selfself,, symbol symbol::  strstr,, interval interval::  strstr))::
                """"""
        ðŸ›‘ Stop a specific WebSocket stream        ðŸ›‘ Stop a specific WebSocket stream
        """        """
        stream_key         stream_key ==  f"f"{{symbolsymbol}}__{{intervalinterval}}""
                
                ifif stream_key  stream_key inin self self..active_streamsactive_streams::
            ws_manager             ws_manager == self self..active_streamsactive_streams[[stream_keystream_key]]
            ws_manager            ws_manager..stopstop(())
                        awaitawait ws_manager ws_manager..disconnectdisconnect(())
ðŸ— Phase 5: Chart Manager & Frontend Integration
5.1 Chart Manager Implementation                        
                        deldel self self..active_streamsactive_streams[[stream_keystream_key]]
                        printprint((f"ðŸ›‘ Stream stopped: f"ðŸ›‘ Stream stopped: {{stream_keystream_key}}""))
                elseelse::
                        printprint((f"âš  Stream not found: f"âš  Stream not found: {{stream_keystream_key}}""))
        asyncasync  defdef  stop_all_streamsstop_all_streams((selfself))::
                """"""
        ðŸ›‘ Stop all active WebSocket streams        ðŸ›‘ Stop all active WebSocket streams
        """        """
                printprint(("ðŸ›‘ Stopping all streams...""ðŸ›‘ Stopping all streams..." ))
                
                forfor stream_key stream_key,, ws_manager  ws_manager inin self self..active_streamsactive_streams..itemsitems(())::
            ws_manager            ws_manager..stopstop(())
                        awaitawait ws_manager ws_manager..disconnectdisconnect(())
                        printprint((f"ðŸ›‘ Stopped: f"ðŸ›‘ Stopped: {{stream_keystream_key}}""))
                
        self        self..active_streamsactive_streams..clearclear(())
                printprint(("âœ… All streams stopped""âœ… All streams stopped"))
        defdef  get_active_streamsget_active_streams((selfself))  -->> List List[[strstr]]::
                """"""
        ðŸ“Š Get list of active stream keys        ðŸ“Š Get list of active stream keys
        """        """
                returnreturn  listlist((selfself..active_streamsactive_streams..keyskeys(())))
python
# apps/trading_platform/chart_manager.py# apps/trading_platform/chart_manager.py
""""""
ðŸ“Š Chart Manager for Lightweight Charts IntegrationðŸ“Š Chart Manager for Lightweight Charts Integration
Handles multi-pane charts, indicators, and real-time updatesHandles multi-pane charts, indicators, and real-time updates
""""""
importimport json json
fromfrom datetime  datetime importimport datetime datetime
fromfrom typing  typing importimport Dict Dict,, List List,, Optional Optional,, Any Any
importimport polars  polars asas pl pl
fromfrom  ..data_manager data_manager importimport DataManager DataManager
fromfrom  ..utilsutils..logger logger importimport get_logger get_logger
logger logger == get_logger get_logger((__name____name__))
classclass  ChartManagerChartManager::
        """"""
    ðŸ“ˆ Advanced Chart Manager    ðŸ“ˆ Advanced Chart Manager
        
    Features:    Features:
    - Multi-pane chart support    - Multi-pane chart support
    - Real-time data updates    - Real-time data updates
    - Indicator toggles and customization    - Indicator toggles and customization
    - Historical data loading    - Historical data loading
    - Time synchronization across panes    - Time synchronization across panes
    """    """
        
        defdef  __init____init__((selfself,, data_manager data_manager:: DataManager DataManager))::
                """Initialize chart manager""""""Initialize chart manager"""
        self        self..data_manager data_manager == data_manager data_manager
                
                # ðŸ“Š Chart configuration# ðŸ“Š Chart configuration
        self        self..chart_config chart_config ==  {{
                        'main_pane''main_pane'::  {{
                                'series''series'::  [['candlestick''candlestick',,  'ema_12''ema_12',,  'ema_26''ema_26',,  'bollinger_bands''bollinger_bands']],,
                                'visible''visible'::  TrueTrue
                        }},,
                        'rsi_pane''rsi_pane'::  {{
                                'series''series'::  [['rsi''rsi']],,
                                'visible''visible'::  TrueTrue,,
                                'height''height'::  150150
                        }},,
                        'macd_pane''macd_pane'::  {{
                                'series''series'::  [['macd''macd',,  'macd_signal''macd_signal',,  'macd_histogram''macd_histogram']],,
                                'visible''visible'::  TrueTrue,,
                                'height''height'::  150150
                        }},,
                        'stoch_pane''stoch_pane'::  {{
                                'series''series'::  [['stochastic''stochastic']],,
                                'visible''visible'::  FalseFalse,,
                                'height''height'::  150150
                        }}
                }}
                
                # ðŸŽ¨ Indicator visibility toggles# ðŸŽ¨ Indicator visibility toggles
        self        self..indicator_visibility indicator_visibility ==  {{
                        'ema_12''ema_12'::  TrueTrue,,
                        'ema_26''ema_26'::  TrueTrue,,
                        'rsi''rsi'::  TrueTrue,,
                        'macd''macd'::  TrueTrue,,
                        'bollinger_bands''bollinger_bands'::  TrueTrue,,
                        'stochastic''stochastic'::  FalseFalse
                }}
                
                printprint(("ðŸ“Š Chart Manager initialized""ðŸ“Š Chart Manager initialized" ))
        logger        logger..infoinfo(("ChartManager ready for charting operations""ChartManager ready for charting operations" ))
        defdef  get_chart_dataget_chart_data((selfself,, symbol symbol::  strstr,, interval interval::  strstr,, limit limit::  intint  ==  300300))  -->> Dict Dict[[strstr
                """"""
        ðŸ“ˆ Get formatted chart data for frontend        ðŸ“ˆ Get formatted chart data for frontend
                
        Returns data in lightweight-charts compatible format        Returns data in lightweight-charts compatible format
        """        """
                printprint((f"ðŸ“ˆ Preparing chart data for f"ðŸ“ˆ Preparing chart data for {{symbolsymbol}}  {{intervalinterval}}..."..."))
                
                # ðŸ“Š Get historical data# ðŸ“Š Get historical data
        df         df == self self..data_managerdata_manager..get_historical_dataget_historical_data((symbolsymbol,, interval interval,, limit limit))
                
                ifif  lenlen((dfdf))  ====  00::
                        printprint((f"âš  No data available for f"âš  No data available for {{symbolsymbol}}  {{intervalinterval}}""))
                        returnreturn self self.._get_empty_chart_data_get_empty_chart_data (())
                
                # ðŸ”„ Convert to chart format# ðŸ”„ Convert to chart format
        chart_data         chart_data == self self.._convert_to_chart_format_convert_to_chart_format ((dfdf))
                
                printprint((f"âœ… Chart data prepared: f"âœ… Chart data prepared: {{lenlen((dfdf))}} candles" candles"))
        logger        logger..infoinfo((f"Chart data prepared for f"Chart data prepared for {{symbolsymbol}}__{{intervalinterval}}: : {{lenlen((dfdf))}} candles" candles"))
                
                returnreturn chart_data chart_data
        defdef  _convert_to_chart_format_convert_to_chart_format ((selfself,, df df:: pl pl..DataFrameDataFrame))  -->> Dict Dict[[strstr,, Any Any]]::
                """"""
        ðŸ”„ Convert Polars DataFrame to lightweight-charts format        ðŸ”„ Convert Polars DataFrame to lightweight-charts format
        """        """
                # ðŸ“Š Main candlestick data# ðŸ“Š Main candlestick data
        candlestick_data         candlestick_data ==  [[]]
        ema_12_data         ema_12_data ==  [[]]
        ema_26_data         ema_26_data ==  [[]]
        rsi_data         rsi_data ==  [[]]
        macd_data         macd_data ==  [[]]
        macd_signal_data         macd_signal_data ==  [[]]
        macd_histogram_data         macd_histogram_data ==  [[]]
        bb_upper_data         bb_upper_data ==  [[]]
        bb_middle_data         bb_middle_data ==  [[]]
        bb_lower_data         bb_lower_data ==  [[]]
        stoch_k_data         stoch_k_data ==  [[]]
        stoch_d_data         stoch_d_data ==  [[]]
                
                forfor row  row inin df df..to_dictsto_dicts(())::
            timestamp             timestamp ==  intint((rowrow[['timestamp''timestamp']]..timestamptimestamp(())))
                        
                        # ðŸ•¯ Candlestick data# ðŸ•¯ Candlestick data
            candlestick_data            candlestick_data..appendappend(({{
                                'time''time':: timestamp timestamp,,
                                'open''open':: row row[['open''open']],,
                                'high''high':: row row[['high''high']],,
                                'low''low':: row row[['low''low']],,
                                'close''close':: row row[['close''close']]
                        }}))
                        
                        # ðŸ“ˆ EMA data# ðŸ“ˆ EMA data
                        ifif row row..getget(('ema_12''ema_12'))  isis  notnot  NoneNone::
                ema_12_data                ema_12_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['ema_12''ema_12']]
                                }}))
                                
                        ifif row row..getget(('ema_26''ema_26'))  isis  notnot  NoneNone::
                ema_26_data                ema_26_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['ema_26''ema_26']]
                                }}))
                        
                        # ðŸ“Š RSI data# ðŸ“Š RSI data
                        ifif row row..getget(('rsi''rsi'))  isis  notnot  NoneNone::
                rsi_data                rsi_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['rsi''rsi']]
                                }}))
                        
                        # ðŸ“ˆ MACD data# ðŸ“ˆ MACD data
                        ifif row row..getget(('macd''macd'))  isis  notnot  NoneNone::
                macd_data                macd_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['macd''macd']]
                                }}))
                                
                        ifif row row..getget(('macd_signal''macd_signal'))  isis  notnot  NoneNone::
                macd_signal_data                macd_signal_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['macd_signal''macd_signal']]
                                }}))
                                
                        ifif row row..getget(('macd_histogram''macd_histogram'))  isis  notnot  NoneNone::
                macd_histogram_data                macd_histogram_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['macd_histogram''macd_histogram']]
                                }}))
                        
                        # ðŸ“Š Bollinger Bands# ðŸ“Š Bollinger Bands
                        ifif row row..getget(('bb_upper''bb_upper'))  isis  notnot  NoneNone::
                bb_upper_data                bb_upper_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['bb_upper''bb_upper']]
                                }}))
                                
                        ifif row row..getget(('bb_middle''bb_middle'))  isis  notnot  NoneNone::
                bb_middle_data                bb_middle_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['bb_middle''bb_middle']]
                                }}))
                                
                        ifif row row..getget(('bb_lower''bb_lower'))  isis  notnot  NoneNone::
                bb_lower_data                bb_lower_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['bb_lower''bb_lower']]
                                }}))
                        
                        # ðŸ“ˆ Stochastic# ðŸ“ˆ Stochastic
                        ifif row row..getget(('stoch_k''stoch_k'))  isis  notnot  NoneNone::
                stoch_k_data                stoch_k_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['stoch_k''stoch_k']]
                                }}))
                                
                        ifif row row..getget(('stoch_d''stoch_d'))  isis  notnot  NoneNone::
                stoch_d_data                stoch_d_data..appendappend(({{
                                        'time''time':: timestamp timestamp,,
                                        'value''value':: row row[['stoch_d''stoch_d']]
                                }}))
                
                returnreturn  {{
                        'candlestick''candlestick':: candlestick_data candlestick_data,,
                        'ema_12''ema_12':: ema_12_data ema_12_data,,
                        'ema_26''ema_26':: ema_26_data ema_26_data,,
                        'rsi''rsi':: rsi_data rsi_data,,
                        'macd''macd':: macd_data macd_data,,
                        'macd_signal''macd_signal':: macd_signal_data macd_signal_data,,
                        'macd_histogram''macd_histogram':: macd_histogram_data macd_histogram_data,,
                        'bb_upper''bb_upper':: bb_upper_data bb_upper_data,,
                        'bb_middle''bb_middle':: bb_middle_data bb_middle_data,,
                        'bb_lower''bb_lower':: bb_lower_data bb_lower_data,,
                        'stoch_k''stoch_k':: stoch_k_data stoch_k_data,,
                        'stoch_d''stoch_d':: stoch_d_data stoch_d_data,,
                        'config''config':: self self..chart_configchart_config,,
                        'visibility''visibility':: self self..indicator_visibilityindicator_visibility
                }}
        defdef  _get_empty_chart_data_get_empty_chart_data ((selfself))  -->> Dict Dict[[strstr,, Any Any]]::
                """"""
        ðŸ“Š Return empty chart data structure        ðŸ“Š Return empty chart data structure
        """        """
                returnreturn  {{
                        'candlestick''candlestick'::  [[]],,
                        'ema_12''ema_12'::  [[]],,
                        'ema_26''ema_26'::  [[]],,
                        'rsi''rsi'::  [[]],,
                        'macd''macd'::  [[]],,
                        'macd_signal''macd_signal'::  [[]],,
                        'macd_histogram''macd_histogram'::  [[]],,
                        'bb_upper''bb_upper'::  [[]],,
                        'bb_middle''bb_middle'::  [[]],,
                        'bb_lower''bb_lower'::  [[]],,
                        'stoch_k''stoch_k'::  [[]],,
                        'stoch_d''stoch_d'::  [[]],,
                        'config''config':: self self..chart_configchart_config,,
                        'visibility''visibility':: self self..indicator_visibilityindicator_visibility
                }}
        defdef  update_indicator_visibilityupdate_indicator_visibility ((selfself,, indicator indicator::  strstr,, visible visible::  boolbool))::
                """"""
        ðŸ‘ Toggle indicator visibility        ðŸ‘ Toggle indicator visibility
        """        """
                ifif indicator  indicator inin self self..indicator_visibilityindicator_visibility ::
            self            self..indicator_visibilityindicator_visibility [[indicatorindicator]]  == visible visible
                        printprint((f"ðŸ‘ f"ðŸ‘ {{indicatorindicator}} visibility:  visibility: {{'ON''ON'  ifif visible  visible elseelse  'OFF''OFF'}}""))
            logger            logger..infoinfo((f"Indicator visibility updated: f"Indicator visibility updated: {{indicatorindicator}} ->  -> {{visiblevisible}}""))
                elseelse::
                        printprint((f"âš  Unknown indicator: f"âš  Unknown indicator: {{indicatorindicator}}""))
        defdef  update_pane_visibilityupdate_pane_visibility ((selfself,, pane pane::  strstr,, visible visible::  boolbool))::
                """"""
        ðŸ“Š Toggle pane visibility        ðŸ“Š Toggle pane visibility
        """        """
                ifif pane  pane inin self self..chart_configchart_config::
            self            self..chart_configchart_config[[panepane]][['visible''visible']]  == visible visible
                        printprint((f"ðŸ“Š f"ðŸ“Š {{panepane}} pane visibility:  pane visibility: {{'ON''ON'  ifif visible  visible elseelse  'OFF''OFF'}}""))
            logger            logger..infoinfo((f"Pane visibility updated: f"Pane visibility updated: {{panepane}} ->  -> {{visiblevisible}}""))
                elseelse::
                        printprint((f"âš  Unknown pane: f"âš  Unknown pane: {{panepane}}""))
        defdef  get_real_time_updateget_real_time_update ((selfself,, symbol symbol::  strstr,, interval interval::  strstr,, ohlc_data ohlc_data))  -->> Dict Dict[[strstr,,  
                """"""
        ðŸ”„ Format real-time data update for frontend        ðŸ”„ Format real-time data update for frontend
                
        This is called by WebSocket callbacks to send live updates        This is called by WebSocket callbacks to send live updates
        """        """
        timestamp         timestamp ==  intint((ohlc_dataohlc_data..timestamptimestamp..timestamptimestamp(())))
                
        update_data         update_data ==  {{
                        'candlestick''candlestick'::  {{
                                'time''time':: timestamp timestamp,,
                                'open''open':: ohlc_data ohlc_data..openopen,,
                                'high''high':: ohlc_data ohlc_data..highhigh,,
                                'low''low':: ohlc_data ohlc_data..lowlow,,
                                'close''close':: ohlc_data ohlc_data..closeclose
                        }}
                }}
                
                # ðŸ“ˆ Add indicator values if available# ðŸ“ˆ Add indicator values if available
                ifif ohlc_data ohlc_data..ema_12 ema_12 isis  notnot  NoneNone::
            update_data            update_data[['ema_12''ema_12']]  ==  {{'time''time':: timestamp timestamp,,  'value''value':: ohlc_data ohlc_data..ema_12ema_12}}
                        
                ifif ohlc_data ohlc_data..ema_26 ema_26 isis  notnot  NoneNone::
            update_data            update_data[['ema_26''ema_26']]  ==  {{'time''time':: timestamp timestamp,,  'value''value':: ohlc_data ohlc_data..ema_26ema_26}}
                        
                ifif ohlc_data ohlc_data..rsi rsi isis  notnot  NoneNone::
            update_data            update_data[['rsi''rsi']]  ==  {{'time''time':: timestamp timestamp,,  'value''value':: ohlc_data ohlc_data..rsirsi}}
                        
                ifif ohlc_data ohlc_data..macd macd isis  notnot  NoneNone::
            update_data            update_data[['macd''macd']]  ==  {{'time''time':: timestamp timestamp,,  'value''value':: ohlc_data ohlc_data..macdmacd}}
                        
                ifif ohlc_data ohlc_data..macd_signal macd_signal isis  notnot  NoneNone::
            update_data            update_data[['macd_signal''macd_signal']]  ==  {{'time''time':: timestamp timestamp,,  'value''value':: ohlc_data ohlc_data..macd_simacd_si
                        
                ifif ohlc_data ohlc_data..macd_histogram macd_histogram isis  notnot  NoneNone::
            update_data            update_data[['macd_histogram''macd_histogram']]  ==  {{'time''time':: timestamp timestamp,,  'value''value':: ohlc_data ohlc_data..macdmacd
                
                returnreturn update_data update_data
classclass  ReplayManagerReplayManager::
        """"""
    â¯ Replay Manager for Historical Data Playback    â¯ Replay Manager for Historical Data Playback
    Simulates live trading with historical data    Simulates live trading with historical data
    """    """
        
        defdef  __init____init__((selfself,, data_manager data_manager:: DataManager DataManager))::
                """Initialize replay manager""""""Initialize replay manager"""
        self        self..data_manager data_manager == data_manager data_manager
        self        self..is_playing is_playing ==  FalseFalse
        self        self..current_position current_position ==  00
        self        self..replay_data replay_data ==  [[]]
        self        self..replay_speed replay_speed ==  1.01.0    # 1x speed# 1x speed
                
                printprint(("â¯ Replay Manager initialized""â¯ Replay Manager initialized" ))
        asyncasync  defdef  start_replaystart_replay((
        self        self,,  
        symbol        symbol::  strstr,,  
        interval        interval::  strstr,,
        start_time        start_time:: datetime datetime,,
        end_time        end_time:: datetime datetime,,
        speed        speed::  floatfloat  ==  1.01.0
        ))::
                """"""
        â–¶ Start historical data replay        â–¶ Start historical data replay
        """        """
                printprint((f"â–¶ Starting replay: f"â–¶ Starting replay: {{symbolsymbol}}  {{intervalinterval}} from  from {{start_timestart_time}} to  to {{end_timeend_time
                
                # ðŸ“Š Load historical data for replay# ðŸ“Š Load historical data for replay
        df         df == self self..data_managerdata_manager..get_historical_dataget_historical_data((
            symbol            symbol,, interval interval,, limit limit==NoneNone
                ))..filterfilter((
                        ((plpl..colcol(('timestamp''timestamp'))  >=>= start_time start_time))  &&  
                        ((plpl..colcol(('timestamp''timestamp'))  <=<= end_time end_time))
                ))
                
                ifif  lenlen((dfdf))  ====  00::
                        printprint((f"âš  No data available for replay period"f"âš  No data available for replay period" ))
                        returnreturn
                
        self        self..replay_data replay_data == df df..to_dictsto_dicts(())
        self        self..replay_speed replay_speed == speed speed
        self        self..current_position current_position ==  00
        self        self..is_playing is_playing ==  TrueTrue
                
                printprint((f"âœ… Replay ready: f"âœ… Replay ready: {{lenlen((selfself..replay_datareplay_data))}} candles at  candles at {{speedspeed}}x speed"x speed"))
        defdef  pause_replaypause_replay((selfself))::
                """â¸ Pause replay""""""â¸ Pause replay"""
        self        self..is_playing is_playing ==  FalseFalse
                printprint(("â¸ Replay paused""â¸ Replay paused"))
        defdef  resume_replayresume_replay((selfself))::
                """â–¶ Resume replay""""""â–¶ Resume replay"""
        self        self..is_playing is_playing ==  TrueTrue
                printprint(("â–¶ Replay resumed""â–¶ Replay resumed"))
        defdef  stop_replaystop_replay((selfself))::
                """â¹ Stop replay""""""â¹ Stop replay"""
        self        self..is_playing is_playing ==  FalseFalse
        self        self..current_position current_position ==  00
                printprint(("â¹ Replay stopped""â¹ Replay stopped"))
        defdef  set_speedset_speed((selfself,, speed speed::  floatfloat))::
                """âš¡ Set replay speed""""""âš¡ Set replay speed"""
        self        self..replay_speed replay_speed == speed speed
                printprint((f"âš¡ Replay speed set to f"âš¡ Replay speed set to {{speedspeed}}x"x"))
        defdef  get_next_candleget_next_candle((selfself))  -->> Optional Optional[[DictDict]]::
                """"""
        âž¡ Get next candle in replay sequence        âž¡ Get next candle in replay sequence
        """        """
                ifif  notnot self self..is_playing is_playing oror self self..current_position current_position >=>=  lenlen((selfself..replay_datareplay_data))::
                        returnreturn  NoneNone
                
        candle         candle == self self..replay_datareplay_data[[selfself..current_positioncurrent_position]]
        self        self..current_position current_position +=+=  11
                
                returnreturn candle candle
        defdef  get_replay_progressget_replay_progress((selfself))  -->> Dict Dict[[strstr,, Any Any]]::
ðŸ— Phase 6: Utility Classes & Error Handling
6.1 Custom Progress Bar Implementation                """"""
        ðŸ“Š Get current replay progress        ðŸ“Š Get current replay progress
        """        """
        total         total ==  lenlen((selfself..replay_datareplay_data))
        current         current == self self..current_positioncurrent_position
                
                returnreturn  {{
                        'current''current':: current current,,
                        'total''total':: total total,,
                        'progress_percent''progress_percent'::  ((current current // total  total **  100100))  ifif total  total >>  00  elseelse  00,,
                        'is_playing''is_playing':: self self..is_playingis_playing,,
                        'speed''speed':: self self..replay_speedreplay_speed
                }}
python
# apps/trading_platform/utils/progress_bar.py# apps/trading_platform/utils/progress_bar.py
""""""
ðŸŽ¨ Custom Progress Bar with Beautiful StylingðŸŽ¨ Custom Progress Bar with Beautiful Styling
Enhanced tqdm with colors, animations, and custom stylesEnhanced tqdm with colors, animations, and custom styles
""""""
importimport time time
importimport random random
fromfrom typing  typing importimport Optional Optional,, List List
fromfrom tqdm  tqdm importimport tqdm tqdm
importimport colorama colorama
fromfrom colorama  colorama importimport Fore Fore,, Style Style
# Initialize colorama for cross-platform color support# Initialize colorama for cross-platform color support
coloramacolorama..initinit(())
classclass  CustomProgressBarCustomProgressBar::
        """"""
    ðŸŒˆ Beautiful Custom Progress Bar    ðŸŒˆ Beautiful Custom Progress Bar
        
    Features:    Features:
    - 5 different colors that change every 20%    - 5 different colors that change every 20%
    - Multiple bar styles (blocks, stars, pipes)    - Multiple bar styles (blocks, stars, pipes)
    - Inline progress display    - Inline progress display
    - Smooth animations    - Smooth animations
    - Custom descriptions    - Custom descriptions
    """    """
        
        defdef  __init____init__((
        self        self,,  
        total        total::  intint,,  
        desc        desc::  strstr  ==  "Processing""Processing",,
        bar_style        bar_style:: Optional Optional[[strstr]]  ==  NoneNone
        ))::
                """"""
        Initialize custom progress bar        Initialize custom progress bar
                
        Args:        Args:
            total: Total number of items to process            total: Total number of items to process
            desc: Description text            desc: Description text
            bar_style: Custom bar style ('blocks', 'stars', 'pipes', 'random')            bar_style: Custom bar style ('blocks', 'stars', 'pipes', 'random')
        """        """
        self        self..total total == total total
        self        self..desc desc == desc desc
        self        self..current current ==  00
                
                # ðŸŽ¨ Color progression (changes every 20%)# ðŸŽ¨ Color progression (changes every 20%)
        self        self..colors colors ==  [[
            Fore            Fore..REDRED,,            # 0-20%# 0-20%
            Fore            Fore..YELLOWYELLOW,,      # 20-40%# 20-40%
            Fore            Fore..BLUEBLUE,,          # 40-60%# 40-60%
            Fore            Fore..MAGENTAMAGENTA,,    # 60-80%# 60-80%
            Fore            Fore..GREEN     GREEN     # 80-100%# 80-100%
                ]]
                
                # ðŸŽ­ Bar styles# ðŸŽ­ Bar styles
        self        self..bar_styles bar_styles ==  {{
                        'blocks''blocks'::  'â–ˆ''â–ˆ',,
                        'stars''stars'::  'â˜…''â˜…',,
                        'pipes''pipes'::  '|''|',,
                        'dots''dots'::  'â—''â—',,
                        'arrows''arrows'::  'â†’''â†’'
                }}
                
                # ðŸŽ² Select bar style# ðŸŽ² Select bar style
                ifif bar_style  bar_style ====  'random''random'::
            self            self..bar_char bar_char == random random..choicechoice((listlist((selfself..bar_stylesbar_styles..valuesvalues(())))))
                elifelif bar_style  bar_style inin self self..bar_stylesbar_styles::
            self            self..bar_char bar_char == self self..bar_stylesbar_styles[[bar_stylebar_style]]
                elseelse::
            self            self..bar_char bar_char == random random..choicechoice((listlist((selfself..bar_stylesbar_styles..valuesvalues(())))))
                
                # ðŸ“Š Initialize tqdm# ðŸ“Š Initialize tqdm
        self        self..pbar pbar == tqdm tqdm((
            total            total==totaltotal,,
            desc            desc==descdesc,,
            bar_format            bar_format=='{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate'{l_bar}{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}, {rate
            ncols            ncols==100100,,
            dynamic_ncols            dynamic_ncols==TrueTrue,,
            leave            leave==TrueTrue
                ))
                
                printprint((f"ðŸŽ¨ Progress bar initialized: f"ðŸŽ¨ Progress bar initialized: {{descdesc}} (style:  (style: {{selfself..bar_charbar_char}})")"))
        defdef  updateupdate((selfself,, n n::  intint  ==  11))::
                """"""
        ðŸ”„ Update progress bar        ðŸ”„ Update progress bar
                
        Args:        Args:
            n: Number of items to add to progress            n: Number of items to add to progress
        """        """
        self        self..current current +=+= n n
                
                # ðŸŒˆ Determine current color based on progress# ðŸŒˆ Determine current color based on progress
        progress_percent         progress_percent ==  ((selfself..current current // self self..totaltotal))  **  100100
        color_index         color_index ==  minmin((intint((progress_percent progress_percent ////  2020)),,  44))
        current_color         current_color == self self..colorscolors[[color_indexcolor_index]]
                
                # ðŸŽ¨ Update with color# ðŸŽ¨ Update with color
        self        self..pbarpbar..set_postfix_strset_postfix_str((f"f"{{current_colorcurrent_color}}{{progress_percentprogress_percent::.1f.1f}}%%{{StyleStyle..RESET_RESET_
        self        self..pbarpbar..updateupdate((nn))
                
                # ðŸŽ‰ Special message at milestones# ðŸŽ‰ Special message at milestones
                ifif progress_percent  progress_percent inin  [[2020,,  4040,,  6060,,  8080]]::
            milestone_msg             milestone_msg ==  f"ðŸŽ¯ f"ðŸŽ¯ {{progress_percentprogress_percent::.0f.0f}}% Complete!"% Complete!"
            self            self..pbarpbar..setConvert to Polars DataFramesetConvert to Polars DataFrame
        df_data         df_data ==  [[]]
                forfor item  item inin items items::
            df_data            df_data..appendappend(({{
                                'timestamp''timestamp':: item item..timestamptimestamp,,
                                'symbol''symbol':: item item..symbolsymbol,,
                                'interval''interval':: item item..intervalinterval,,
                                'open''open':: item item..openopen,,
                                'high''high':: item item..highhigh,,
                                'low''low':: item item..lowlow,,
                                'close''close':: item item..closeclose,,
                                'volume''volume':: item item..volumevolume,,
                                'ema_12''ema_12':: item item..ema_12ema_12,,
                                'ema_26''ema_26':: item item..ema_26ema_26,,
                                'rsi''rsi':: item item..rsirsi,,
                                'macd''macd':: item item..macdmacd,,
                                'macd_signal''macd_signal':: item item..macd_signalmacd_signal,,
                                'macd_histogram''macd_histogram':: item item..macd_histogrammacd_histogram,,
                                'bb_upper''bb_upper':: item item..bb_upperbb_upper,,
                                'bb_middle''bb_middle':: item item..bb_middlebb_middle,,
                                'bb_lower''bb_lower':: item item..bb_lowerbb_lower,,
                                'stoch_k''stoch_k':: item item..stoch_kstoch_k,,
                                'stoch_d''stoch_d':: item item..stoch_dstoch_d,,
                        }}))
                
        df         df == pl pl..DataFrameDataFrame((df_datadf_data))
                
                # ðŸ’« Store using DuckDB-Polars integration# ðŸ’« Store using DuckDB-Polars integration
        conn         conn == self self.._get_connection_get_connection((symbolsymbol,, interval interval))
                
                # Use UPSERT to handle duplicates gracefully# Use UPSERT to handle duplicates gracefully
        conn        conn..executeexecute((""""""
            INSERT OR REPLACE INTO ohlc_data             INSERT OR REPLACE INTO ohlc_data 
            SELECT * FROM df            SELECT * FROM df
        """        """))
                
                printprint((f"âœ¨ Stored f"âœ¨ Stored {{lenlen((itemsitems))}} records for  records for {{symbolsymbol}}__{{intervalinterval}}""))
        defdef  get_historical_dataget_historical_data((
        self        self,,  
        symbol        symbol::  strstr,,  
        interval        interval::  strstr,,  
        limit        limit::  intint  ==  300300,,
        start_time        start_time:: Optional Optional[[datetimedatetime]]  ==  NoneNone,,
        end_time        end_time:: Optional Optional[[datetimedatetime]]  ==  NoneNone
        ))  -->> pl pl..DataFrameDataFrame::
                """"""
        âš¡ Retrieve historical OHLC data with lightning speed        âš¡ Retrieve historical OHLC data with lightning speed
                
        Args:        Args:
            symbol: Trading symbol (e.g., 'BTCUSDT')            symbol: Trading symbol (e.g., 'BTCUSDT')
            interval: Time interval (e.g., '1m', '1h')            interval: Time interval (e.g., '1m', '1h')
            limit: Maximum number of records            limit: Maximum number of records
            start_time: Optional start timestamp            start_time: Optional start timestamp
            end_time: Optional end timestamp            end_time: Optional end timestamp
                        
        Returns:        Returns:
            Polars DataFrame with OHLC + indicator data            Polars DataFrame with OHLC + indicator data
        """        """
                trytry::
            conn             conn == self self.._get_connection_get_connection((symbolsymbol,, interval interval))
                        
                        # ðŸ” Build query based on parameters# ðŸ” Build query based on parameters
            query             query ==  "SELECT * FROM ohlc_data WHERE 1=1""SELECT * FROM ohlc_data WHERE 1=1"
            params             params ==  [[]]
                        
                        ifif start_time start_time::
                query                 query +=+=  " AND timestamp >= ?"" AND timestamp >= ?"
                params                params..appendappend((start_timestart_time))
                                
                        ifif end_time end_time::
                query                 query +=+=  " AND timestamp <= ?"" AND timestamp <= ?"
                params                params..appendappend((end_timeend_time))
                                
            query             query +=+=  " ORDER BY timestamp DESC"" ORDER BY timestamp DESC"
                        
                        ifif limit limit::
                query                 query +=+=  f" LIMIT f" LIMIT {{limitlimit}}""
                        
                        # âš¡ Execute query and return as Polars DataFrame# âš¡ Execute query and return as Polars DataFrame
            result             result == conn conn..executeexecute((queryquery,, params params))..fetch_arrow_tablefetch_arrow_table(())
            df             df == pl pl..from_arrowfrom_arrow((resultresult))
ðŸ— Phase 3: Technical Indicators Engine
3.1 Indicator Calculations
Why This Implementation:
Pure Python calculations for transparency and customization
Vectorized operations using Polars for speed
Modular design allows easy addition of new indicators
Real-time calculation capability for live data                        
            logger            logger..infoinfo((f"ðŸ“ˆ Retrieved f"ðŸ“ˆ Retrieved {{lenlen((dfdf))}} records for  records for {{symbolsymbol}}__{{intervalinterval}}""))
                        printprint((f"ðŸ“Š Loaded f"ðŸ“Š Loaded {{lenlen((dfdf))}} historical candles for  historical candles for {{symbolsymbol}}__{{intervalinterval}}""))
                        
                        returnreturn df df..sortsort(('timestamp''timestamp'))
                        
                exceptexcept Exception  Exception asas e e::
            logger            logger..errorerror((f"âŒ Failed to retrieve data for f"âŒ Failed to retrieve data for {{symbolsymbol}}__{{intervalinterval}}: : {{ee}}""))
                        printprint((f"âš   Query failed for f"âš   Query failed for {{symbolsymbol}}__{{intervalinterval}}: : {{ee}}""))
                        returnreturn pl pl..DataFrameDataFrame(())
        defdef  get_latest_candleget_latest_candle((selfself,, symbol symbol::  strstr,, interval interval::  strstr))  -->> Optional Optional[[OHLCDataOHLCData]]::
                """"""
        ðŸ”¥ Get the most recent candle for symbol+interval        ðŸ”¥ Get the most recent candle for symbol+interval
        Used for seamless live data continuation        Used for seamless live data continuation
        """        """
                trytry::
            conn             conn == self self.._get_connection_get_connection((symbolsymbol,, interval interval))
                        
            result             result == conn conn..executeexecute((""""""
                SELECT * FROM ohlc_data                 SELECT * FROM ohlc_data 
                ORDER BY timestamp DESC                 ORDER BY timestamp DESC 
                LIMIT 1                LIMIT 1
            """            """))..fetchonefetchone(())
                        
                        ifif result result::
                                returnreturn OHLCData OHLCData((**resultresult))
                                
                exceptexcept Exception  Exception asas e e::
            logger            logger..errorerror((f"âŒ Failed to get latest candle for f"âŒ Failed to get latest candle for {{symbolsymbol}}__{{intervalinterval}}: : {{ee}}
                        
                returnreturn  NoneNone
        defdef  cleanup_connectionscleanup_connections((selfself))::
                """"""
        ðŸ”’ Clean up database connections        ðŸ”’ Clean up database connections
        Call this when shutting down the application        Call this when shutting down the application
        """        """
                forfor key key,, conn  conn inin self self.._connections_connections..itemsitems(())::
            conn            conn..closeclose(())
                        printprint((f"ðŸ” Closed connection: f"ðŸ” Closed connection: {{keykey}}""))
                        
        self        self.._connections_connections..clearclear(())
        logger        logger..infoinfo(("âœ… All database connections closed""âœ… All database connections closed" ))
python
# apps/trading_platform/indicators.py# apps/trading_platform/indicators.py
""""""
ðŸ“Š Technical Indicators EngineðŸ“Š Technical Indicators Engine
Implements popular trading indicators with high performanceImplements popular trading indicators with high performance
All calculations are vectorized using Polars for speedAll calculations are vectorized using Polars for speed
""""""
importimport polars  polars asas pl pl
importimport numpy  numpy asas np np
fromfrom typing  typing importimport Tuple Tuple,, Optional Optional
fromfrom  ..utilsutils..logger logger importimport get_logger get_logger
logger logger == get_logger get_logger((__name____name__))
classclass  TechnicalIndicatorsTechnicalIndicators::
        """"""
    ðŸ”§ High-Performance Technical Indicators    ðŸ”§ High-Performance Technical Indicators
        
    Features:    Features:
    - Vectorized calculations using Polars    - Vectorized calculations using Polars
    - Real-time indicator updates    - Real-time indicator updates
    - Memory-efficient operations    - Memory-efficient operations
    - Easy parameter customization    - Easy parameter customization
    """    """
        
        @staticmethod@staticmethod
        defdef  calculate_emacalculate_ema((dfdf:: pl pl..DataFrameDataFrame,, column column::  strstr  ==  'close''close',, period period::  intint  ==  1212))  -->> pl pl
                """"""
        ðŸ“ˆ Exponential Moving Average        ðŸ“ˆ Exponential Moving Average
                
        EMA gives more weight to recent prices, making it more responsive        EMA gives more weight to recent prices, making it more responsive
        Formula: EMA = (Close * Î±) + (Previous_EMA * (1 - Î±))        Formula: EMA = (Close * Î±) + (Previous_EMA * (1 - Î±))
        where Î± = 2 / (period + 1)        where Î± = 2 / (period + 1)
        """        """
                printprint((f"ðŸ”„ Calculating EMA(f"ðŸ”„ Calculating EMA({{periodperiod}}) for ) for {{lenlen((dfdf))}} candles..." candles..."))
                
        closes         closes == df df[[columncolumn]]..to_numpyto_numpy(())
        alpha         alpha ==  2.02.0  //  ((period period ++  11))
        ema_values         ema_values == np np..zeros_likezeros_like((closescloses))
                
                # Initialize first EMA as first close price# Initialize first EMA as first close price
        ema_values        ema_values[[00]]  == closes closes[[00]]
                
                # Calculate EMA for each subsequent period# Calculate EMA for each subsequent period
                forfor i  i inin  rangerange((11,,  lenlen((closescloses))))::
            ema_values            ema_values[[ii]]  ==  ((closescloses[[ii]]  ** alpha alpha))  ++  ((ema_valuesema_values[[ii--11]]  **  ((11  -- alpha alpha))))
                
        logger        logger..infoinfo((f"âœ… EMA(f"âœ… EMA({{periodperiod}}) calculated successfully") calculated successfully" ))
                returnreturn pl pl..SeriesSeries((ema_valuesema_values))
        @staticmethod@staticmethod
        defdef  calculate_rsicalculate_rsi((dfdf:: pl pl..DataFrameDataFrame,, column column::  strstr  ==  'close''close',, period period::  intint  ==  1414))  -->> pl pl
                """"""
        ðŸ“Š Relative Strength Index        ðŸ“Š Relative Strength Index
                
        RSI measures the speed and magnitude of price changes        RSI measures the speed and magnitude of price changes
        Values range from 0-100, with 70+ indicating overbought, 30- oversold        Values range from 0-100, with 70+ indicating overbought, 30- oversold
        """        """
                printprint((f"ðŸ”„ Calculating RSI(f"ðŸ”„ Calculating RSI({{periodperiod}}) for ) for {{lenlen((dfdf))}} candles..." candles..."))
                
        closes         closes == df df[[columncolumn]]..to_numpyto_numpy(())
        deltas         deltas == np np..diffdiff((closescloses))
                
                # Separate gains and losses# Separate gains and losses
        gains         gains == np np..wherewhere((deltas deltas >>  00,, deltas deltas,,  00))
        losses         losses == np np..wherewhere((deltas deltas <<  00,,  --deltasdeltas,,  00))
                
                # Calculate initial averages# Calculate initial averages
        avg_gain         avg_gain == np np..meanmean((gainsgains[[::periodperiod]]))
        avg_loss         avg_loss == np np..meanmean((losseslosses[[::periodperiod]]))
                
        rsi_values         rsi_values == np np..zeroszeros((lenlen((closescloses))))
        rsi_values        rsi_values[[::periodperiod]]  == np np..nannan
                
                # Calculate RSI for each period# Calculate RSI for each period
                forfor i  i inin  rangerange((periodperiod,,  lenlen((closescloses))))::
                        ifif i  i ==== period period::
                                # First RSI calculation# First RSI calculation
                rs                 rs == avg_gain  avg_gain // avg_loss  avg_loss ifif avg_loss  avg_loss !=!=  00  elseelse  00
                        elseelse::
                                # Smooth the averages (Wilder's smoothing)# Smooth the averages (Wilder's smoothing)
                avg_gain                 avg_gain ==  ((((avg_gain avg_gain **  ((period period --  11))))  ++ gains gains[[ii--11]]))  // period period
                avg_loss                 avg_loss ==  ((((avg_loss avg_loss **  ((period period --  11))))  ++ losses losses[[ii--11]]))  // period period
                rs                 rs == avg_gain  avg_gain // avg_loss  avg_loss ifif avg_loss  avg_loss !=!=  00  elseelse  00
                        
            rsi_values            rsi_values[[ii]]  ==  100100  --  ((100100  //  ((11  ++ rs rs))))
                
        logger        logger..infoinfo((f"âœ… RSI(f"âœ… RSI({{periodperiod}}) calculated successfully") calculated successfully" ))
                returnreturn pl pl..SeriesSeries((rsi_valuesrsi_values))
        @staticmethod@staticmethod
        defdef  calculate_macdcalculate_macd((
        df        df:: pl pl..DataFrameDataFrame,,  
        column        column::  strstr  ==  'close''close',,
        fast_period        fast_period::  intint  ==  1212,,
        slow_period        slow_period::  intint  ==  2626,,
        signal_period        signal_period::  intint  ==  99
        ))  -->> Tuple Tuple[[plpl..SeriesSeries,, pl pl..SeriesSeries,, pl pl..SeriesSeries]]::
                """"""
        ðŸ“ˆ MACD (Moving Average Convergence Divergence)        ðŸ“ˆ MACD (Moving Average Convergence Divergence)
                
        MACD shows the relationship between two EMAs        MACD shows the relationship between two EMAs
        Returns: (MACD Line, Signal Line, Histogram)        Returns: (MACD Line, Signal Line, Histogram)
        """        """
                printprint((f"ðŸ”„ Calculating MACD(f"ðŸ”„ Calculating MACD({{fast_periodfast_period}},,{{slow_periodslow_period}},,{{signal_periodsignal_period}})...")..."))
                
                # Calculate fast and slow EMAs# Calculate fast and slow EMAs
        fast_ema         fast_ema == TechnicalIndicators TechnicalIndicators..calculate_emacalculate_ema((dfdf,, column column,, fast_period fast_period))
        slow_ema         slow_ema == TechnicalIndicators TechnicalIndicators..calculate_emacalculate_ema((dfdf,, column column,, slow_period slow_period))
                
                # MACD line = Fast EMA - Slow EMA# MACD line = Fast EMA - Slow EMA
        macd_line         macd_line == fast_ema  fast_ema -- slow_ema slow_ema
                
                # Signal line = EMA of MACD line# Signal line = EMA of MACD line
        macd_df         macd_df == pl pl..DataFrameDataFrame(({{'macd''macd':: macd_line macd_line}}))
        signal_line         signal_line == TechnicalIndicators TechnicalIndicators..calculate_emacalculate_ema((macd_dfmacd_df,,  'macd''macd',, signal_period signal_period
                
                # Histogram = MACD - Signal# Histogram = MACD - Signal
        histogram         histogram == macd_line  macd_line -- signal_line signal_line
                
        logger        logger..infoinfo(("âœ… MACD calculated successfully""âœ… MACD calculated successfully" ))
                returnreturn macd_line macd_line,, signal_line signal_line,, histogram histogram
        @staticmethod@staticmethod
        defdef  calculate_bollinger_bandscalculate_bollinger_bands ((
        df        df:: pl pl..DataFrameDataFrame,,
        column        column::  strstr  ==  'close''close',,
        period        period::  intint  ==  2020,,
        std_dev        std_dev::  floatfloat  ==  2.02.0
        ))  -->> Tuple Tuple[[plpl..SeriesSeries,, pl pl..SeriesSeries,, pl pl..SeriesSeries]]::
                """"""
        ðŸ“Š Bollinger Bands        ðŸ“Š Bollinger Bands
                
        Bands that expand and contract based on market volatility        Bands that expand and contract based on market volatility
        Returns: (Upper Band, Middle Band/SMA, Lower Band)        Returns: (Upper Band, Middle Band/SMA, Lower Band)
        """        """
                printprint((f"ðŸ”„ Calculating Bollinger Bands(f"ðŸ”„ Calculating Bollinger Bands( {{periodperiod}}, , {{std_devstd_dev}})...")..."))
                
                # Calculate Simple Moving Average (Middle Band)# Calculate Simple Moving Average (Middle Band)
        sma         sma == df df[[columncolumn]]..rolling_meanrolling_mean((window_sizewindow_size==periodperiod))
                
                # Calculate standard deviation# Calculate standard deviation
        std         std == df df[[columncolumn]]..rolling_stdrolling_std((window_sizewindow_size==periodperiod))
                
                # Calculate bands# Calculate bands
        upper_band         upper_band == sma  sma ++  ((std std ** std_dev std_dev))
        lower_band         lower_band == sma  sma --  ((std std ** std_dev std_dev))
                
        logger        logger..infoinfo(("âœ… Bollinger Bands calculated successfully""âœ… Bollinger Bands calculated successfully" ))
                returnreturn upper_band upper_band,, sma sma,, lower_band lower_band
        @staticmethod@staticmethod
        defdef  calculate_stochasticcalculate_stochastic ((
        df        df:: pl pl..DataFrameDataFrame,,
        high_col        high_col::  strstr  ==  'high''high',,
        low_col        low_col::  strstr  ==  'low''low',,  
        close_col        close_col::  strstr  ==  'close''close',,
        k_period        k_period::  intint  ==  1414,,
        d_period        d_period::  intint  ==  33
        ))  -->> Tuple Tuple[[plpl..SeriesSeries,, pl pl..SeriesSeries]]::
                """"""
        ðŸ“ˆ Stochastic Oscillator        ðŸ“ˆ Stochastic Oscillator
                
        Compares closing price to price range over time        Compares closing price to price range over time
        Returns: (%K, %D)        Returns: (%K, %D)
        """        """
                printprint((f"ðŸ”„ Calculating Stochastic(f"ðŸ”„ Calculating Stochastic( {{k_periodk_period}}, , {{d_periodd_period}})...")..."))
                
                # Calculate %K# Calculate %K
        lowest_low         lowest_low == df df[[low_collow_col]]..rolling_minrolling_min((window_sizewindow_size==k_periodk_period))
        highest_high         highest_high == df df[[high_colhigh_col]]..rolling_maxrolling_max((window_sizewindow_size==k_periodk_period))
                
        k_percent         k_percent ==  ((((dfdf[[close_colclose_col]]  -- lowest_low lowest_low))  //  ((highest_high highest_high -- lowest_low lowest_low))))  **  100100
                
                # Calculate %D (SMA of %K)# Calculate %D (SMA of %K)
        d_percent         d_percent == k_percent k_percent..rolling_meanrolling_mean((window_sizewindow_size==d_periodd_period))
                
        logger        logger..infoinfo(("âœ… Stochastic calculated successfully""âœ… Stochastic calculated successfully" ))
                returnreturn k_percent k_percent,, d_percent d_percent
classclass  IndicatorManagerIndicatorManager::
        """"""
    ðŸŽ› Indicator Management System    ðŸŽ› Indicator Management System
    Handles real-time indicator calculations and updates    Handles real-time indicator calculations and updates
    """    """
        
        defdef  __init____init__((selfself))::
                """Initialize indicator manager with default parameters""""""Initialize indicator manager with default parameters"""
        self        self..indicators indicators == TechnicalIndicators TechnicalIndicators(())
                
                # ðŸ“Š Default indicator parameters (easily customizable)# ðŸ“Š Default indicator parameters (easily customizable)
        self        self..params params ==  {{
                        'ema_12''ema_12'::  {{'period''period'::  1212}},,
                        'ema_26''ema_26'::  {{'period''period'::  2626}},,
                        'rsi''rsi'::  {{'period''period'::  1414}},,
                        'macd''macd'::  {{'fast''fast'::  1212,,  'slow''slow'::  2626,,  'signal''signal'::  99}},,
                        'bollinger''bollinger'::  {{'period''period'::  2020,,  'std_dev''std_dev'::  2.02.0}},,
                        'stochastic''stochastic'::  {{'k_period''k_period'::  1414,,  'd_period''d_period'::  33}}
                }}
                
                printprint(("ðŸŽ› Indicator Manager initialized with default parameters""ðŸŽ› Indicator Manager initialized with default parameters" ))
        logger        logger..infoinfo(("IndicatorManager ready for calculations""IndicatorManager ready for calculations" ))
        defdef  calculate_all_indicatorscalculate_all_indicators ((selfself,, df df:: pl pl..DataFrameDataFrame))  -->> pl pl..DataFrameDataFrame::
                """"""
        ðŸš€ Calculate all indicators for a DataFrame        ðŸš€ Calculate all indicators for a DataFrame
                
        This is the main function that adds all indicator columns        This is the main function that adds all indicator columns
        to your OHLC data for storage and charting        to your OHLC data for storage and charting
        """        """
                ifif  lenlen((dfdf))  <<  5050::    # Need sufficient data for indicators# Need sufficient data for indicators
            logger            logger..warningwarning((f"âš  Insufficient data for indicators: f"âš  Insufficient data for indicators: {{lenlen((dfdf))}} candles" candles"))
                        returnreturn df df
                        
                printprint((f"ðŸ”§ Computing all indicators for f"ðŸ”§ Computing all indicators for {{lenlen((dfdf))}} candles..." candles..."))
        result_df         result_df == df df..cloneclone(())
                
                trytry::
                        # ðŸ“ˆ EMAs# ðŸ“ˆ EMAs
            result_df             result_df == result_df result_df..with_columnswith_columns(([[
                self                self..indicatorsindicators..calculate_emacalculate_ema((dfdf,,  'close''close',,  1212))..aliasalias(('ema_12''ema_12')),,
                self                self..indicatorsindicators..calculate_emacalculate_ema((dfdf,,  'close''close',,  2626))..aliasalias(('ema_26''ema_26'))
                        ]]))
                        
                        # ðŸ“Š RSI# ðŸ“Š RSI
            result_df             result_df == result_df result_df..with_columnswith_columns(([[
                self                self..indicatorsindicators..calculate_rsicalculate_rsi((dfdf,,  'close''close',,  1414))..aliasalias(('rsi''rsi'))
                        ]]))
                        
                        # ðŸ“ˆ MACD# ðŸ“ˆ MACD
            macd            macd,, signal signal,, histogram  histogram == self self..indicatorsindicators..calculate_macdcalculate_macd((dfdf))
            result_df             result_df == result_df result_df..with_columnswith_columns(([[
                macd                macd..aliasalias(('macd''macd')),,
                signal                signal..aliasalias(('macd_signal''macd_signal')),,
                histogram                histogram..aliasalias(('macd_histogram''macd_histogram'))
                        ]]))
                        
                        # ðŸ“Š Bollinger Bands# ðŸ“Š Bollinger Bands
            bb_upper            bb_upper,, bb_middle bb_middle,, bb_lower  bb_lower == self self..indicatorsindicators..calculate_bollinger_bandscalculate_bollinger_bands ((dd
            result_df             result_df == result_df result_df..with_columnswith_columns(([[
                bb_upper                bb_upper..aliasalias(('bb_upper''bb_upper')),,
                bb_middle                bb_middle..aliasalias(('bb_middle''bb_middle')),,
                bb_lower                bb_lower..aliasalias(('bb_lower''bb_lower'))
                        ]]))
                        
                        # ðŸ“ˆ Stochastic# ðŸ“ˆ Stochastic
            stoch_k            stoch_k,, stoch_d  stoch_d == self self..indicatorsindicators..calculate_stochasticcalculate_stochastic ((dfdf))
            result_df             result_df == result_df result_df..with_columnswith_columns(([[
                stoch_k                stoch_k..aliasalias(('stoch_k''stoch_k')),,
ðŸ— Phase 4: WebSocket Manager & Real-time Data
4.1 WebSocket Implementation
Why This Architecture:
Clean separation between WebSocket handling and data processing
Automatic reconnection and error recovery
Efficient data streaming with minimal latency
Easy symbol/interval switching without connection issues                stoch_d                stoch_d..aliasalias(('stoch_d''stoch_d'))
                        ]]))
                        
                        printprint(("âœ… All indicators calculated successfully!""âœ… All indicators calculated successfully!" ))
            logger            logger..infoinfo((f"âœ… Indicators calculated for f"âœ… Indicators calculated for {{lenlen((dfdf))}} candles" candles"))
                        
                        returnreturn result_df result_df
                        
                exceptexcept Exception  Exception asas e e::
            logger            logger..errorerror((f"âŒ Indicator calculation failed: f"âŒ Indicator calculation failed: {{ee}}""))
                        printprint((f"âš  Indicator calculation error: f"âš  Indicator calculation error: {{ee}}""))
                        returnreturn df df
        defdef  update_parametersupdate_parameters((selfself,, indicator indicator::  strstr,,  ****kwargskwargs))::
                """"""
        ðŸŽ› Update indicator parameters        ðŸŽ› Update indicator parameters
                
        Example:         Example: 
        manager.update_parameters('rsi', period=21)        manager.update_parameters('rsi', period=21)
        manager.update_parameters('macd', fast=10, slow=21, signal=7)        manager.update_parameters('macd', fast=10, slow=21, signal=7)
        """        """
                ifif indicator  indicator inin self self..paramsparams::
            self            self..paramsparams[[indicatorindicator]]..updateupdate((kwargskwargs))
                        printprint((f"ðŸ”§ Updated f"ðŸ”§ Updated {{indicatorindicator}} parameters:  parameters: {{kwargskwargs}}""))
            logger            logger..infoinfo((f"Indicator parameters updated: f"Indicator parameters updated: {{indicatorindicator}} ->  -> {{kwargskwargs}}""))
                elseelse::
                        printprint((f"âš  Unknown indicator: f"âš  Unknown indicator: {{indicatorindicator}}""))
python
# apps/trading_platform/websocket_manager.py# apps/trading_platform/websocket_manager.py
""""""
ðŸŒ WebSocket Manager for Real-time Market DataðŸŒ WebSocket Manager for Real-time Market Data
Handles Binance WebSocket streams with automatic reconnectionHandles Binance WebSocket streams with automatic reconnection
""""""
importimport asyncio asyncio
importimport json json
importimport websockets websockets
fromfrom datetime  datetime importimport datetime datetime
fromfrom typing  typing importimport Dict Dict,, Callable Callable,, Optional Optional,, List List
importimport logging logging
fromfrom  ..models models importimport OHLCData OHLCData
fromfrom  ..indicators indicators importimport IndicatorManager IndicatorManager
fromfrom  ..data_manager data_manager importimport DataManager DataManager
fromfrom  ..utilsutils..logger logger importimport get_logger get_logger
fromfrom  ..utilsutils..error_handler error_handler importimport ErrorHandler ErrorHandler
logger logger == get_logger get_logger((__name____name__))
classclass  BinanceWebSocketManagerBinanceWebSocketManager ::
        """"""
    ðŸš€ High-Performance WebSocket Manager    ðŸš€ High-Performance WebSocket Manager
        
    Features:    Features:
    - Automatic reconnection on failures    - Automatic reconnection on failures
    - Dynamic symbol/interval switching    - Dynamic symbol/interval switching
    - Real-time indicator calculations    - Real-time indicator calculations
    - Efficient data batching and storage    - Efficient data batching and storage
    - Clean teardown and initialization    - Clean teardown and initialization
    """    """
        
        defdef  __init____init__((selfself,, data_manager data_manager:: DataManager DataManager))::
                """"""
        Initialize WebSocket manager        Initialize WebSocket manager
                
        Args:        Args:
            data_manager: DataManager instance for storing OHLC data            data_manager: DataManager instance for storing OHLC data
        """        """
        self        self..data_manager data_manager == data_manager data_manager
        self        self..indicator_manager indicator_manager == IndicatorManager IndicatorManager(())
        self        self..error_handler error_handler == ErrorHandler ErrorHandler(())
                
                # ðŸ”— Connection management# ðŸ”— Connection management
        self        self..websocketwebsocket:: Optional Optional[[websocketswebsockets..WebSocketServerProtocolWebSocketServerProtocol ]]  ==  NoneNone
        self        self..is_connected is_connected ==  FalseFalse
        self        self..should_reconnect should_reconnect ==  TrueTrue
                
                # ðŸ“Š Current streaming configuration# ðŸ“Š Current streaming configuration
        self        self..current_symbol current_symbol ==  NoneNone
        self        self..current_interval current_interval ==  NoneNone
        self        self..stream_url stream_url ==  NoneNone
                
                # ðŸ“ˆ Data callbacks (for updating charts)# ðŸ“ˆ Data callbacks (for updating charts)
        self        self..data_callbacksdata_callbacks:: List List[[CallableCallable]]  ==  [[]]
                
                # ðŸ”„ Reconnection settings# ðŸ”„ Reconnection settings
        self        self..reconnect_delay reconnect_delay ==  55    # seconds# seconds
        self        self..max_reconnect_attempts max_reconnect_attempts ==  1010
        self        self..reconnect_attempts reconnect_attempts ==  00
                
                printprint(("ðŸŒ WebSocket Manager initialized""ðŸŒ WebSocket Manager initialized" ))
        logger        logger..infoinfo(("BinanceWebSocketManager ready for connections""BinanceWebSocketManager ready for connections" ))
        defdef  add_data_callbackadd_data_callback((selfself,, callback callback:: Callable Callable))::
                """"""
        ðŸ“¡ Add callback function for real-time data updates        ðŸ“¡ Add callback function for real-time data updates
                
        Callbacks will be called with (symbol, interval, ohlc_data)        Callbacks will be called with (symbol, interval, ohlc_data)
        Perfect for updating charts in real-time        Perfect for updating charts in real-time
        """        """
        self        self..data_callbacksdata_callbacks..appendappend((callbackcallback))
                printprint((f"ðŸ“¡ Added data callback: f"ðŸ“¡ Added data callback: {{callbackcallback..__name____name__}}""))
        defdef  _build_stream_url_build_stream_url((selfself,, symbol symbol::  strstr,, interval interval::  strstr))  -->>  strstr::
                """"""
        ðŸ”— Build Binance WebSocket stream URL        ðŸ”— Build Binance WebSocket stream URL
                
        Format: wss://stream.binance.com:9443/ws/btcusdt@kline_1m        Format: wss://stream.binance.com:9443/ws/btcusdt@kline_1m
        """        """
        symbol_lower         symbol_lower == symbol symbol..lowerlower(())
        stream_name         stream_name ==  f"f"{{symbol_lowersymbol_lower}}@kline_@kline_{{intervalinterval}}""
                returnreturn  f"wss://stream.binance.com:9443/ws/f"wss://stream.binance.com:9443/ws/ {{stream_namestream_name}}""
        asyncasync  defdef  connectconnect((selfself,, symbol symbol::  strstr,, interval interval::  strstr))  -->>  boolbool::
                """"""
        ðŸ”Œ Connect to Binance WebSocket stream        ðŸ”Œ Connect to Binance WebSocket stream
                
        Args:        Args:
            symbol: Trading symbol (e.g., 'BTCUSDT')            symbol: Trading symbol (e.g., 'BTCUSDT')
            interval: Time interval (e.g., '1m', '1h', '1d')            interval: Time interval (e.g., '1m', '1h', '1d')
                        
        Returns:        Returns:
            True if connection successful, False otherwise            True if connection successful, False otherwise
        """        """
                printprint((f"ðŸ”Œ Connecting to f"ðŸ”Œ Connecting to {{symbolsymbol}}  {{intervalinterval}} stream..." stream..."))
                
                # ðŸ”„# ðŸ”„


        *********** First continuation **********************
TradingView-like Platform: Continuation Implementation Guide
Current Status Assessment
Based on your screenshots, you've successfully implemented:
âœ… Real-time WebSocket data streaming from Binance
âœ… Multi-pane chart layout (Main, RSI, MACD panes)
âœ… Technical indicators calculation (RSI, MACD, EMA, Bollinger Bands)
âœ… Time synchronization across panes
âœ… Basic symbol and interval selection
Phase 1: Immediate Improvements & Bug Fixes
1.1 Clean Up the UI Layout
Current Issue: The interface shows overlapping text and data streams Solution: Implement proper CSS
styling and layout management
1.2 Implement DuckDB Data Persistence
Priority: High - This is missing from your current implementationhtml
<!-- templates/trading/chart.html --> <!-- templates/trading/chart.html -->
<<divdiv  classclass==""trading-container trading-container"">>
        <<divdiv  classclass==""header-controlsheader-controls"">>
                <<divdiv  classclass==""symbol-selectorsymbol-selector"">>
                        <<selectselect  idid==""symbol-dropdownsymbol-dropdown"">>
                                <<optionoption  valuevalue==""BTCUSDTBTCUSDT"">>BTCUSDTBTCUSDT</</optionoption>>
                                <<optionoption  valuevalue==""ETHUSDTETHUSDT"">>ETHUSDTETHUSDT</</optionoption>>
                                <<optionoption  valuevalue==""BNBUSDTBNBUSDT"">>BNBUSDTBNBUSDT</</optionoption>>
                        </</selectselect>>
                </</divdiv>>
                <<divdiv  classclass==""interval-selector interval-selector"">>
                        <<selectselect  idid==""interval-dropdown interval-dropdown"">>
                                <<optionoption  valuevalue==""1m1m"">>1m1m</</optionoption>>
                                <<optionoption  valuevalue==""3m3m"">>3m3m</</optionoption>>
                                <<optionoption  valuevalue==""5m5m"">>5m5m</</optionoption>>
                                <<optionoption  valuevalue==""15m15m"">>15m15m</</optionoption>>
                                <<optionoption  valuevalue==""30m30m"">>30m30m</</optionoption>>
                                <<optionoption  valuevalue==""1h1h"">>1h1h</</optionoption>>
                                <<optionoption  valuevalue==""4h4h"">>4h4h</</optionoption>>
                                <<optionoption  valuevalue==""1d1d"">>1d1d</</optionoption>>
                        </</selectselect>>
                </</divdiv>>
        </</divdiv>>
        
        <<divdiv  classclass==""chart-containerchart-container"">>
                <<divdiv  classclass==""main-chart-panemain-chart-pane""  idid==""main-chartmain-chart"">></</divdiv>>
                <<divdiv  classclass==""indicator-panesindicator-panes"">>
                        <<divdiv  classclass==""rsi-panersi-pane""  idid==""rsi-chartrsi-chart"">></</divdiv>>
                        <<divdiv  classclass==""macd-panemacd-pane""  idid==""macd-chartmacd-chart"">></</divdiv>>
                </</divdiv>>
        </</divdiv>>
        
        <<divdiv  classclass==""sidebar-panelsidebar-panel""  idid==""sidebarsidebar"">>
                <!-- Symbol info, price, change % --> <!-- Symbol info, price, change % -->
        </</divdiv>>
</</divdiv>>

python
# apps/trading/models.py # apps/trading/models.py
importimport duckdb duckdb
importimport polars  polars asas pl pl
fromfrom pathlib  pathlib importimport Path Path
importimport logging logging
fromfrom typing  typing importimport Dict Dict,, List List,, Optional Optional
fromfrom datetime  datetime importimport datetime datetime
classclass  DuckDBManager DuckDBManager::
        """"""
    ðŸ¦† DuckDB Manager for OHLC + Technical Indicators Storage     ðŸ¦† DuckDB Manager for OHLC + Technical Indicators Storage
        
    Each symbol+interval combination gets its own .duckdb file     Each symbol+interval combination gets its own .duckdb file
    Structure: timestamp, symbol, interval, open, high, low, close,     Structure: timestamp, symbol, interval, open, high, low, close, 
              ema_20, rsi_14, macd_line, macd_signal, bb_upper, bb_lower               ema_20, rsi_14, macd_line, macd_signal, bb_upper, bb_lower
    """    """
        
        defdef  __init____init__((selfself,, data_dir data_dir::  strstr  ==  "data/duckdb""data/duckdb"))::
        self        self..data_dir data_dir == Path Path((data_dirdata_dir))
        self        self..data_dirdata_dir..mkdirmkdir((parentsparents==TrueTrue,, exist_ok exist_ok==TrueTrue))
        self        self..connectionsconnections:: Dict Dict[[strstr,, duckdb duckdb..DuckDBPyConnection DuckDBPyConnection]]  ==  {{}}
                
                # ðŸŽ¨ Beautiful progress bar setup # ðŸŽ¨ Beautiful progress bar setup
        self        self..progress_styles progress_styles ==  [['[|||||| {}]''[|||||| {}]',,  '[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ {}]''[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ {}]',,  '[â˜…â˜…â˜…â˜…â˜… {}]''[â˜…â˜…â˜…â˜…â˜… {}]',,  '[â™¦â™¦â™¦â™¦â™¦ {}'[â™¦â™¦â™¦â™¦â™¦ {}
                
                printprint(("ðŸ¦† DuckDB Manager initialized successfully!" "ðŸ¦† DuckDB Manager initialized successfully!"))
                printprint((f"ðŸ“ Data directory: f"ðŸ“ Data directory: {{selfself..data_dirdata_dir..absoluteabsolute(())}}""))
        
        defdef  get_connectionget_connection((selfself,, symbol symbol::  strstr,, interval interval::  strstr))  -->> duckdb duckdb..DuckDBPyConnection DuckDBPyConnection::
                """"""
        Get or create DuckDB connection for specific symbol+interval         Get or create DuckDB connection for specific symbol+interval
                
        Args:        Args:
            symbol: Trading symbol (e.g., 'BTCUSDT')             symbol: Trading symbol (e.g., 'BTCUSDT')
            interval: Time interval (e.g., '1m', '5m', '1h')             interval: Time interval (e.g., '1m', '5m', '1h')
                        
        Returns:        Returns:
            DuckDB connection instance             DuckDB connection instance
        """        """
        key         key ==  f"f"{{symbolsymbol}}__{{intervalinterval}}""
                
                ifif key  key notnot  inin self self..connectionsconnections::
            db_path             db_path == self self..data_dir data_dir //  f"f"{{keykey}}.duckdb".duckdb"
            conn             conn == duckdb duckdb..connectconnect((strstr((db_pathdb_path))))
                        
                        # ðŸ— Create table if not exists # ðŸ— Create table if not exists
            conn            conn..executeexecute((""""""
                CREATE TABLE IF NOT EXISTS ohlc_indicators (                 CREATE TABLE IF NOT EXISTS ohlc_indicators (
                    timestamp TIMESTAMP PRIMARY KEY,                     timestamp TIMESTAMP PRIMARY KEY,
                    symbol VARCHAR NOT NULL,                     symbol VARCHAR NOT NULL,
                    interval VARCHAR NOT NULL,                     interval VARCHAR NOT NULL,
                    open DOUBLE NOT NULL,                     open DOUBLE NOT NULL,
                    high DOUBLE NOT NULL,                     high DOUBLE NOT NULL,
                    low DOUBLE NOT NULL,                     low DOUBLE NOT NULL,
                    close DOUBLE NOT NULL,                     close DOUBLE NOT NULL,
                    volume DOUBLE NOT NULL,                     volume DOUBLE NOT NULL,
                    ema_20 DOUBLE,                     ema_20 DOUBLE,
                    rsi_14 DOUBLE,                     rsi_14 DOUBLE,
                    macd_line DOUBLE,                     macd_line DOUBLE,
                    macd_signal DOUBLE,                     macd_signal DOUBLE,
                    macd_histogram DOUBLE,                     macd_histogram DOUBLE,
                    bb_upper DOUBLE,                     bb_upper DOUBLE,
                    bb_middle DOUBLE,                     bb_middle DOUBLE,
                    bb_lower DOUBLE,                     bb_lower DOUBLE,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP                     created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )                 )
            """            """))
                        
            self            self..connectionsconnections[[keykey]]  == conn conn
                        printprint((f"ðŸ“Š Created DuckDB table for f"ðŸ“Š Created DuckDB table for {{symbolsymbol}}  {{intervalinterval}}""))
                        
                returnreturn self self..connectionsconnections[[keykey]]
        
        defdef  insert_candle_data insert_candle_data((selfself,, symbol symbol::  strstr,, interval interval::  strstr,, candle_data candle_data:: Dict Dict))::
                """"""
        Insert OHLC + indicators data into DuckDB         Insert OHLC + indicators data into DuckDB
                
        Args:        Args:
            symbol: Trading symbol             symbol: Trading symbol
            interval: Time interval              interval: Time interval  
            candle_data: Dictionary containing OHLC + indicator values             candle_data: Dictionary containing OHLC + indicator values
        """        """
        conn         conn == self self..get_connectionget_connection((symbolsymbol,, interval interval))
                
                trytry::
            conn            conn..executeexecute((""""""
                INSERT OR REPLACE INTO ohlc_indicators                 INSERT OR REPLACE INTO ohlc_indicators 
                (timestamp, symbol, interval, open, high, low, close, volume,                 (timestamp, symbol, interval, open, high, low, close, volume,
                 ema_20, rsi_14, macd_line, macd_signal, macd_histogram,                  ema_20, rsi_14, macd_line, macd_signal, macd_histogram,
                 bb_upper, bb_middle, bb_lower)                  bb_upper, bb_middle, bb_lower)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)                 VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """            """,,  ((
                candle_data                 candle_data[['timestamp''timestamp']],,
                symbol                 symbol,,
                interval                 interval,,
                candle_data                 candle_data[['open''open']],,
                candle_data                 candle_data[['high''high']],,  
                candle_data                 candle_data[['low''low']],,
                candle_data                 candle_data[['close''close']],,
                candle_data                 candle_data[['volume''volume']],,
                candle_data                 candle_data..getget(('ema_20''ema_20')),,
                candle_data                 candle_data..getget(('rsi_14''rsi_14')),,
                candle_data                 candle_data..getget(('macd_line''macd_line')),,
                candle_data                 candle_data..getget(('macd_signal''macd_signal')),,
                candle_data                 candle_data..getget(('macd_histogram''macd_histogram')),,
                candle_data                 candle_data..getget(('bb_upper''bb_upper')),,
                candle_data                 candle_data..getget(('bb_middle''bb_middle')),,
                candle_data                 candle_data..getget(('bb_lower''bb_lower'))
                        ))))
                        
                        printprint((f"ðŸ’¾ Saved f"ðŸ’¾ Saved {{symbolsymbol}}  {{intervalinterval}} candle at  candle at {{candle_datacandle_data[['timestamp''timestamp']]}}""
                        
                exceptexcept Exception  Exception asas e e::
            logging             logging..errorerror((f"âŒ Error inserting candle data: f"âŒ Error inserting candle data: {{ee}}""))
                        # ðŸ“§ Email notification setup (commented for now) # ðŸ“§ Email notification setup (commented for now)
                        # self.send_error_notification(f"DuckDB Insert Error: {e}") # self.send_error_notification(f"DuckDB Insert Error: {e}")
        
        defdef  get_historical_candles get_historical_candles((selfself,, symbol symbol::  strstr,, interval interval::  strstr,, limit limit::  intint  ==  300300))  -->>  
                """"""
        Fetch historical candles using Polars for blazing speed         Fetch historical candles using Polars for blazing speed
                
        Args:        Args:
            symbol: Trading symbol             symbol: Trading symbol
            interval: Time interval             interval: Time interval
1.3 Enhanced WebSocket Handler with DuckDB Integration            limit: Number of recent candles to fetch             limit: Number of recent candles to fetch
                        
        Returns:        Returns:
            Polars DataFrame with historical data             Polars DataFrame with historical data
        """        """
        conn         conn == self self..get_connectionget_connection((symbolsymbol,, interval interval))
                
        query         query ==  f"""f"""
            SELECT * FROM ohlc_indicators             SELECT * FROM ohlc_indicators 
            WHERE symbol = '             WHERE symbol = '{{symbolsymbol}}' AND interval = ' ' AND interval = '{{intervalinterval}}''
            ORDER BY timestamp DESC             ORDER BY timestamp DESC 
            LIMIT             LIMIT {{limitlimit}}
        """        """
                
                # ðŸš€ Use Polars for lightning-fast data processing # ðŸš€ Use Polars for lightning-fast data processing
        df         df == pl pl..read_databaseread_database((queryquery,, conn conn))
                
                ifif  notnot df df..is_emptyis_empty(())::
                        printprint((f"ðŸ“ˆ Loaded f"ðŸ“ˆ Loaded {{lenlen((dfdf))}} historical candles for  historical candles for {{symbolsymbol}}  {{intervalinterval}}""))
                        returnreturn df df..sortsort(('timestamp''timestamp'))
                elseelse::
                        printprint((f"ðŸ“Š No historical data found for f"ðŸ“Š No historical data found for {{symbolsymbol}}  {{intervalinterval}}""))
                        returnreturn pl pl..DataFrameDataFrame(())
python
# apps/trading/websocket_handler.py # apps/trading/websocket_handler.py
importimport asyncio asyncio
importimport json json
importimport websockets websockets
fromfrom channels channels..genericgeneric..websocket websocket importimport AsyncWebsocketConsumer  AsyncWebsocketConsumer
fromfrom  ..models models importimport DuckDBManager DuckDBManager
fromfrom  ..indicators indicators importimport TechnicalIndicators  TechnicalIndicators
importimport logging logging
fromfrom typing  typing importimport Dict Dict,, List List
importimport time time
fromfrom tqdm  tqdm importimport tqdm tqdm
importimport random random
classclass  TradingWebSocketConsumer TradingWebSocketConsumer((AsyncWebsocketConsumer AsyncWebsocketConsumer))::
        """"""
    ðŸš€ Enhanced WebSocket Consumer with DuckDB persistence     ðŸš€ Enhanced WebSocket Consumer with DuckDB persistence
    Handles real-time Binance data + technical indicators     Handles real-time Binance data + technical indicators
    """    """
        
        defdef  __init____init__((selfself,,  **argsargs,,  ****kwargskwargs))::
                supersuper(())..__init____init__((**argsargs,,  ****kwargskwargs))
        self        self..duckdb_manager duckdb_manager == DuckDBManager DuckDBManager(())
        self        self..indicators indicators == TechnicalIndicators  TechnicalIndicators(())
        self        self..binance_ws binance_ws ==  NoneNone
        self        self..current_symbol current_symbol ==  "BTCUSDT""BTCUSDT"
        self        self..current_interval current_interval ==  "1m""1m"
                
                # ðŸŽ¨ Progress bar customization # ðŸŽ¨ Progress bar customization
        self        self..progress_colors progress_colors ==  [['\033[91m''\033[91m',,  '\033[93m''\033[93m',,  '\033[92m''\033[92m',,  '\033[94m''\033[94m',,  '\033[9'\033[9
        self        self..progress_styles progress_styles ==  [['[|||||| {}]''[|||||| {}]',,  '[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ {}]''[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ {}]',,  '[â˜…â˜…â˜…â˜…â˜… {}]''[â˜…â˜…â˜…â˜…â˜… {}]']]
                
                printprint(("ðŸš€ Trading WebSocket Consumer initialized!" "ðŸš€ Trading WebSocket Consumer initialized!"))
        
        asyncasync  defdef  connectconnect((selfself))::
                """Accept WebSocket connection and load historical data""" """Accept WebSocket connection and load historical data"""
                awaitawait self self..acceptaccept(())
                
                printprint(("ðŸ”Œ WebSocket connection established" "ðŸ”Œ WebSocket connection established"))
                
                # ðŸ“Š Load historical data first # ðŸ“Š Load historical data first
                awaitawait self self..load_historical_data load_historical_data(())
                
                # ðŸ”„ Start Binance WebSocket connection # ðŸ”„ Start Binance WebSocket connection
                awaitawait self self..start_binance_stream start_binance_stream(())
        
        asyncasync  defdef  disconnectdisconnect((selfself,, close_code close_code))::
                """Clean disconnection with proper teardown""" """Clean disconnection with proper teardown"""
                printprint((f"ðŸ”Œ WebSocket disconnecting with code: f"ðŸ”Œ WebSocket disconnecting with code: {{close_codeclose_code}}""))
                
                ifif self self..binance_wsbinance_ws::
                        awaitawait self self..binance_wsbinance_ws..closeclose(())
                        printprint(("ðŸ”’ Binance WebSocket connection closed" "ðŸ”’ Binance WebSocket connection closed"))
        
        asyncasync  defdef  receivereceive((selfself,, text_data text_data))::
                """Handle incoming WebSocket messages""" """Handle incoming WebSocket messages"""
                trytry::
            data             data == json json..loadsloads((text_datatext_data))
            message_type             message_type == data data..getget(('type''type'))
                        
                        ifif message_type  message_type ====  'symbol_change''symbol_change'::
                                awaitawait self self..change_symbolchange_symbol((datadata[['symbol''symbol']],, data data[['interval''interval']]))
                        elifelif message_type  message_type ====  'replay_start''replay_start'::
                                awaitawait self self..start_replaystart_replay((datadata))
                        elifelif message_type  message_type ====  'toggle_indicator' 'toggle_indicator'::
                                awaitawait self self..toggle_indicatortoggle_indicator((datadata[['indicator''indicator']],, data data[['enabled''enabled']]))
                                
                exceptexcept json json..JSONDecodeError JSONDecodeError asas e e::
            logging             logging..errorerror((f"âŒ JSON decode error: f"âŒ JSON decode error: {{ee}}""))
                exceptexcept Exception  Exception asas e e::
            logging             logging..errorerror((f"âŒ WebSocket receive error: f"âŒ WebSocket receive error: {{ee}}""))
        
        asyncasync  defdef  load_historical_data load_historical_data((selfself))::
                """"""
        ðŸ”„ Load historical candles from DuckDB on chart startup         ðŸ”„ Load historical candles from DuckDB on chart startup
        Provides instant chart population before live data begins         Provides instant chart population before live data begins
        """        """
                printprint((f"ðŸ“Š Loading historical data for f"ðŸ“Š Loading historical data for {{selfself..current_symbolcurrent_symbol}}  {{selfself..current_intcurrent_int
                
                # Get historical data using Polars # Get historical data using Polars
        df         df == self self..duckdb_managerduckdb_manager..get_historical_candles get_historical_candles((
            self            self..current_symbolcurrent_symbol,,  
            self            self..current_intervalcurrent_interval,,  
            limit             limit==300300
                ))
                
                ifif  notnot df df..is_emptyis_empty(())::
                        # ðŸŽ¨ Beautiful progress bar for historical data loading # ðŸŽ¨ Beautiful progress bar for historical data loading
            progress_style             progress_style == random random..choicechoice((selfself..progress_stylesprogress_styles))
            color             color == random random..choicechoice((selfself..progress_colorsprogress_colors))
                        
                        withwith tqdm tqdm((totaltotal==lenlen((dfdf)),, desc desc==f"f"{{colorcolor}}ðŸ“ˆ Loading History" ðŸ“ˆ Loading History",,  
                     bar_format                      bar_format==progress_styleprogress_style))  asas pbar pbar::
                                
                                forfor row  row inin df df..iter_rowsiter_rows((namednamed==TrueTrue))::
                                        # Send historical candle to frontend # Send historical candle to frontend
                                        awaitawait self self..sendsend((text_datatext_data==jsonjson..dumpsdumps(({{
                                                'type''type'::  'historical_candle' 'historical_candle',,
                                                'data''data'::  {{
                                                        'timestamp''timestamp':: row row[['timestamp''timestamp']]..isoformatisoformat(()),,
                                                        'open''open':: row row[['open''open']],,
                                                        'high''high':: row row[['high''high']],,  
                                                        'low''low':: row row[['low''low']],,
                                                        'close''close':: row row[['close''close']],,
                                                        'volume''volume':: row row[['volume''volume']],,
                                                        'indicators''indicators'::  {{
                                                                'ema_20''ema_20':: row row[['ema_20''ema_20']],,
                                                                'rsi_14''rsi_14':: row row[['rsi_14''rsi_14']],,
                                                                'macd''macd'::  {{
                                                                        'macd''macd':: row row[['macd_line''macd_line']],,
                                                                        'signal''signal':: row row[['macd_signal''macd_signal']],,
                                                                        'histogram''histogram':: row row[['macd_histogram''macd_histogram']]
                                                                }},,
                                                                'bollinger''bollinger'::  {{
                                                                        'upper''upper':: row row[['bb_upper''bb_upper']],,
                                                                        'middle''middle':: row row[['bb_middle''bb_middle']],,
                                                                        'lower''lower':: row row[['bb_lower''bb_lower']]
                                                                }}
                                                        }}
                                                }}
                                        }}))))
                                        
                    pbar                     pbar..updateupdate((11))
                                        awaitawait asyncio asyncio..sleepsleep((0.010.01))    # Smooth loading animation # Smooth loading animation
                        
                        printprint((f"âœ… Historical data loaded: f"âœ… Historical data loaded: {{lenlen((dfdf))}} candles" candles"))
                elseelse::
                        printprint(("ðŸ“Š No historical data available, starting fresh" "ðŸ“Š No historical data available, starting fresh"))
        
        asyncasync  defdef  start_binance_stream start_binance_stream((selfself))::
                """"""
        ðŸ”„ Start real-time Binance WebSocket stream         ðŸ”„ Start real-time Binance WebSocket stream
        Continues after historical data is loaded         Continues after historical data is loaded
        """        """
        stream_url         stream_url ==  f"wss://stream.binance.com:9443/ws/ f"wss://stream.binance.com:9443/ws/{{selfself..current_symbolcurrent_symbol..lowerlower(())}}@@
                
                printprint((f"ðŸ”„ Starting Binance stream: f"ðŸ”„ Starting Binance stream: {{stream_urlstream_url}}""))
                
                trytry::
                        asyncasync  withwith websockets websockets..connectconnect((stream_urlstream_url))  asas websocket websocket::
                self                 self..binance_ws binance_ws == websocket websocket
                                printprint(("âœ… Connected to Binance WebSocket" "âœ… Connected to Binance WebSocket"))
                                
                                asyncasync  forfor message  message inin websocket websocket::
                                        awaitawait self self..process_binance_message process_binance_message((messagemessage))
                                        
                exceptexcept Exception  Exception asas e e::
            logging             logging..errorerror((f"âŒ Binance WebSocket error: f"âŒ Binance WebSocket error: {{ee}}""))
                        # ðŸ”„ Retry connection after delay # ðŸ”„ Retry connection after delay
                        awaitawait asyncio asyncio..sleepsleep((55))
                        awaitawait self self..start_binance_stream start_binance_stream(())
        
        asyncasync  defdef  process_binance_message process_binance_message((selfself,, message message::  strstr))::
                """"""
        Process incoming Binance kline data         Process incoming Binance kline data
        Calculate indicators and persist to DuckDB         Calculate indicators and persist to DuckDB
        """        """
                trytry::
            data             data == json json..loadsloads((messagemessage))
            kline             kline == data data[['k''k']]
                        
                        # Extract OHLCV data # Extract OHLCV data
            candle_data             candle_data ==  {{
                                'timestamp''timestamp':: pd pd..to_datetimeto_datetime((klinekline[['t''t']],, unit unit=='ms''ms')),,
                                'open''open'::  floatfloat((klinekline[['o''o']])),,
                                'high''high'::  floatfloat((klinekline[['h''h']])),,
                                'low''low'::  floatfloat((klinekline[['l''l']])),,
                                'close''close'::  floatfloat((klinekline[['c''c']])),,
                                'volume''volume'::  floatfloat((klinekline[['v''v']]))
                        }}
                        
                        # ðŸ§® Calculate technical indicators # ðŸ§® Calculate technical indicators
            indicators             indicators == self self..indicatorsindicators..calculate_allcalculate_all((
                self                 self..current_symbolcurrent_symbol,,  
                self                 self..current_intervalcurrent_interval,,  
                candle_data                 candle_data
                        ))
                        
                        # Merge indicators with candle data # Merge indicators with candle data
            candle_data             candle_data..updateupdate((indicatorsindicators))
                        
                        # ðŸ’¾ Persist to DuckDB # ðŸ’¾ Persist to DuckDB
            self            self..duckdb_managerduckdb_manager..insert_candle_data insert_candle_data((
                self                 self..current_symbolcurrent_symbol,,
                self                 self..current_intervalcurrent_interval,,  
                candle_data                 candle_data
                        ))
Phase 2: Advanced Features Implementation
2.1 Replay Functionality                        
                        # ðŸ“¡ Send to frontend # ðŸ“¡ Send to frontend
                        awaitawait self self..sendsend((text_datatext_data==jsonjson..dumpsdumps(({{
                                'type''type'::  'live_candle''live_candle',,
                                'data''data':: candle_data candle_data
                        }}))))
                        
                        printprint((f"ðŸ“Š Processed live candle: f"ðŸ“Š Processed live candle: {{selfself..current_symbolcurrent_symbol}}  {{candle_datacandle_data[['clos'clos
                        
                exceptexcept Exception  Exception asas e e::
            logging             logging..errorerror((f"âŒ Error processing Binance message: f"âŒ Error processing Binance message: {{ee}}""))
python
# apps/trading/replay.py # apps/trading/replay.py
importimport asyncio asyncio
fromfrom datetime  datetime importimport datetime datetime,, timedelta timedelta
fromfrom typing  typing importimport Optional Optional
importimport polars  polars asas pl pl
fromfrom  ..models models importimport DuckDBManager DuckDBManager
classclass  ReplayEngine ReplayEngine::
        """"""
    â¯ TradingView-style Replay Engine     â¯ TradingView-style Replay Engine
    Streams historical data with speed control     Streams historical data with speed control
    """    """
        
        defdef  __init____init__((selfself,, duckdb_manager duckdb_manager:: DuckDBManager DuckDBManager))::
        self        self..duckdb_manager duckdb_manager == duckdb_manager duckdb_manager
        self        self..is_playing is_playing ==  FalseFalse
        self        self..current_speed current_speed ==  1.01.0    # 1x, 2x, 5x, 10x # 1x, 2x, 5x, 10x
        self        self..current_position current_position ==  00
                
        asyncasync  defdef  start_replaystart_replay((selfself,, symbol symbol::  strstr,, interval interval::  strstr,,  
                          start_time                           start_time:: datetime datetime,, end_time end_time:: datetime datetime,,
                          speed                           speed::  floatfloat  ==  1.01.0,, websocket_consumer  websocket_consumer==NoneNone))::
                """"""
        ðŸŽ¬ Start replay with specified parameters         ðŸŽ¬ Start replay with specified parameters
                
        Args:        Args:
            symbol: Trading symbol             symbol: Trading symbol
            interval: Time interval             interval: Time interval
            start_time: Replay start time             start_time: Replay start time
            end_time: Replay end time              end_time: Replay end time  
            speed: Playback speed multiplier             speed: Playback speed multiplier
            websocket_consumer: WebSocket to send data to             websocket_consumer: WebSocket to send data to
        """        """
                printprint((f"ðŸŽ¬ Starting replay for f"ðŸŽ¬ Starting replay for {{symbolsymbol}}  {{intervalinterval}}""))
                printprint((f"â± Period: f"â± Period: {{start_timestart_time}} to  to {{end_timeend_time}}""))
                printprint((f"ðŸš€ Speed: f"ðŸš€ Speed: {{speedspeed}}x"x"))
                
                # Get historical data for replay period # Get historical data for replay period
        df         df == self self..get_replay_dataget_replay_data((symbolsymbol,, interval interval,, start_time start_time,, end_time end_time))
                
                ifif df df..is_emptyis_empty(())::
                        printprint(("âŒ No data available for replay period" "âŒ No data available for replay period"))
                        returnreturn
                
        self        self..is_playing is_playing ==  TrueTrue
        self        self..current_speed current_speed == speed speed
                
                # Calculate delay between candles based on speed # Calculate delay between candles based on speed
        base_delay         base_delay == self self..get_base_delayget_base_delay((intervalinterval))
        delay         delay == base_delay  base_delay // speed speed
                
                printprint((f"ðŸ“Š Replaying f"ðŸ“Š Replaying {{lenlen((dfdf))}} candles with  candles with {{delaydelay::.2f.2f}}s delay"s delay"))
                
                forfor i i,, row  row inin  enumerateenumerate((dfdf..iter_rowsiter_rows((namednamed==TrueTrue))))::
                        ifif  notnot self self..is_playingis_playing::
                                breakbreak
                                
            self            self..current_position current_position == i i
                        
                        # Send candle data to WebSocket # Send candle data to WebSocket
                        ifif websocket_consumer  websocket_consumer::
                                awaitawait websocket_consumer  websocket_consumer..sendsend((text_datatext_data==jsonjson..dumpsdumps(({{
2.2 Enhanced Technical Indicators                                        'type''type'::  'replay_candle''replay_candle',,
                                        'data''data'::  dictdict((rowrow)),,
                                        'replay_info''replay_info'::  {{
                                                'position''position':: i i,,
                                                'total''total'::  lenlen((dfdf)),,
                                                'progress''progress'::  ((i i //  lenlen((dfdf))))  **  100100,,
                                                'speed''speed':: speed speed
                                        }}
                                }}))))
                        
                        awaitawait asyncio asyncio..sleepsleep((delaydelay))
                
                printprint(("ðŸ Replay completed" "ðŸ Replay completed"))
        self        self..is_playing is_playing ==  FalseFalse
python
# apps/trading/indicators.py # apps/trading/indicators.py
importimport pandas  pandas asas pd pd
importimport numpy  numpy asas np np
fromfrom typing  typing importimport Dict Dict,, List List,, Optional Optional
importimport talib talib
fromfrom dataclasses  dataclasses importimport dataclass dataclass
@dataclass@dataclass
classclass  IndicatorConfig IndicatorConfig::
        """Configuration for technical indicators""" """Configuration for technical indicators"""
    rsi_period    rsi_period::  intint  ==  1414
    ema_period    ema_period::  intint  ==  2020
    macd_fast    macd_fast::  intint  ==  1212
    macd_slow    macd_slow::  intint  ==  2626
    macd_signal    macd_signal::  intint  ==  99
    bb_period    bb_period::  intint  ==  2020
    bb_std    bb_std::  floatfloat  ==  2.02.0
classclass  TechnicalIndicators TechnicalIndicators::
        """"""
    ðŸ“Š Comprehensive Technical Indicators Calculator     ðŸ“Š Comprehensive Technical Indicators Calculator
    Supports 7+ popular indicators with customizable parameters     Supports 7+ popular indicators with customizable parameters
    """    """
        
        defdef  __init____init__((selfself,, config config:: Optional Optional[[IndicatorConfigIndicatorConfig]]  ==  NoneNone))::
        self        self..config config == config  config oror IndicatorConfig IndicatorConfig(())
        self        self..price_historyprice_history:: Dict Dict[[strstr,, List List[[floatfloat]]]]  ==  {{}}
                
                printprint(("ðŸ“Š Technical Indicators engine initialized" "ðŸ“Š Technical Indicators engine initialized"))
                
        defdef  calculate_allcalculate_all((selfself,, symbol symbol::  strstr,, interval interval::  strstr,, candle_data candle_data:: Dict Dict))  -->> Dict Dict::
                """"""
        Calculate all enabled technical indicators         Calculate all enabled technical indicators
                
        Returns:        Returns:
            Dictionary containing all indicator values             Dictionary containing all indicator values
        """        """
                # Update price history # Update price history
        key         key ==  f"f"{{symbolsymbol}}__{{intervalinterval}}""
                ifif key  key notnot  inin self self..price_historyprice_history::
            self            self..price_historyprice_history[[keykey]]  ==  [[]]
                        
        self        self..price_historyprice_history[[keykey]]..appendappend((candle_datacandle_data[['close''close']]))
                
                # Keep only last 200 prices for indicator calculation # Keep only last 200 prices for indicator calculation
                ifif  lenlen((selfself..price_historyprice_history[[keykey]]))  >>  200200::
            self            self..price_historyprice_history[[keykey]]  == self self..price_historyprice_history[[keykey]][[--200200::]]
                
        prices         prices == np np..arrayarray((selfself..price_historyprice_history[[keykey]]))
                
        indicators         indicators ==  {{}}
                
                # ðŸ“ˆ RSI (Relative Strength Index) # ðŸ“ˆ RSI (Relative Strength Index)
                ifif  lenlen((pricesprices))  >=>= self self..configconfig..rsi_periodrsi_period::
            rsi             rsi == talib talib..RSIRSI((pricesprices,, timeperiod timeperiod==selfself..configconfig..rsi_periodrsi_period))
            indicators             indicators[['rsi_14''rsi_14']]  == rsi rsi[[--11]]  ifif  notnot np np..isnanisnan((rsirsi[[--11]]))  elseelse  NoneNone
                
                # ðŸ“Š EMA (Exponential Moving Average) # ðŸ“Š EMA (Exponential Moving Average) 
                ifif  lenlen((pricesprices))  >=>= self self..configconfig..ema_periodema_period::
            ema             ema == talib talib..EMAEMA((pricesprices,, timeperiod timeperiod==selfself..configconfig..ema_periodema_period))
            indicators             indicators[['ema_20''ema_20']]  == ema ema[[--11]]  ifif  notnot np np..isnanisnan((emaema[[--11]]))  elseelse  NoneNone
                
Phase 3: Frontend Enhancements
3.1 Improved Chart Layout                # ðŸ”„ MACD (Moving Average Convergence Divergence) # ðŸ”„ MACD (Moving Average Convergence Divergence)
                ifif  lenlen((pricesprices))  >=>= self self..configconfig..macd_slowmacd_slow::
            macd            macd,, signal signal,, histogram  histogram == talib talib..MACDMACD((pricesprices,,  
                                              fastperiod                                               fastperiod==selfself..configconfig..macd_fastmacd_fast,,
                                              slowperiod                                               slowperiod==selfself..configconfig..macd_slowmacd_slow,,
                                              signalperiod                                               signalperiod==selfself..configconfig..macd_signalmacd_signal))
            indicators             indicators..updateupdate(({{
                                'macd_line''macd_line':: macd macd[[--11]]  ifif  notnot np np..isnanisnan((macdmacd[[--11]]))  elseelse  NoneNone,,
                                'macd_signal''macd_signal':: signal signal[[--11]]  ifif  notnot np np..isnanisnan((signalsignal[[--11]]))  elseelse  NoneNone,,
                                'macd_histogram''macd_histogram':: histogram histogram[[--11]]  ifif  notnot np np..isnanisnan((histogramhistogram[[--11]]))  elseelse  NonNon
                        }}))
                
                # ðŸ“ Bollinger Bands # ðŸ“ Bollinger Bands
                ifif  lenlen((pricesprices))  >=>= self self..configconfig..bb_periodbb_period::
            bb_upper             bb_upper,, bb_middle bb_middle,, bb_lower  bb_lower == talib talib..BBANDSBBANDS((pricesprices,,
                                                        timeperiod                                                         timeperiod==selfself..configconfig..bb_periobb_perio
                                                        nbdevup                                                         nbdevup==selfself..configconfig..bb_stdbb_std,,
                                                        nbdevdn                                                         nbdevdn==selfself..configconfig..bb_stdbb_std))
            indicators             indicators..updateupdate(({{
                                'bb_upper''bb_upper':: bb_upper bb_upper[[--11]]  ifif  notnot np np..isnanisnan((bb_upperbb_upper[[--11]]))  elseelse  NoneNone,,
                                'bb_middle''bb_middle':: bb_middle bb_middle[[--11]]  ifif  notnot np np..isnanisnan((bb_middlebb_middle[[--11]]))  elseelse  NoneNone,,  
                                'bb_lower''bb_lower':: bb_lower bb_lower[[--11]]  ifif  notnot np np..isnanisnan((bb_lowerbb_lower[[--11]]))  elseelse  NoneNone
                        }}))
                
                returnreturn indicators indicators
javascript
// static/js/trading_chart.js // static/js/trading_chart.js
classclass  TradingChart TradingChart  {{
        constructorconstructor((containerIdcontainerId))  {{
                thisthis..containercontainer  ==  documentdocument..getElementByIdgetElementById((containerIdcontainerId));;
                thisthis..chartscharts  ==  {{}};;
                thisthis..indicatorsindicators  ==  {{
                        rsirsi::  truetrue,,
                        macdmacd::  truetrue,,  
                        emaema::  truetrue,,
                        bollingerbollinger::  truetrue
                }};;
                
                thisthis..initializeChartsinitializeCharts(());;
                thisthis..setupWebSocketsetupWebSocket(());;
                thisthis..setupControllerssetupControllers(());;
                
                consoleconsole..loglog(("ðŸ“Š Trading Chart initialized" "ðŸ“Š Trading Chart initialized"));;
        }}
        
        initializeChartsinitializeCharts(())  {{
                // ðŸ“Š Main candlestick chart // ðŸ“Š Main candlestick chart
                thisthis..chartscharts..mainmain  ==  LightweightCharts LightweightCharts..createChartcreateChart((
                        thisthis..containercontainer..querySelectorquerySelector(('#main-chart''#main-chart')),,  {{
                                widthwidth::  thisthis..containercontainer..clientWidthclientWidth,,
                                heightheight::  400400,,
                                layoutlayout::  {{
                                        backgroundColorbackgroundColor::  '#1a1a1a''#1a1a1a',,
                                        textColortextColor::  '#ffffff''#ffffff',,
                                }},,
                                gridgrid::  {{
                                        vertLinesvertLines::  {{  colorcolor::  '#2a2a2a''#2a2a2a'  }},,
                                        horzLineshorzLines::  {{  colorcolor::  '#2a2a2a''#2a2a2a'  }}
                                }},,
                                timeScaletimeScale::  {{
                                        timeVisibletimeVisible::  truetrue,,
                                        secondsVisiblesecondsVisible::  falsefalse,,
                                }}
                        }}
                ));;
                
                // ðŸ“ˆ RSI Chart (separate pane) // ðŸ“ˆ RSI Chart (separate pane)
                thisthis..chartscharts..rsirsi  ==  LightweightCharts LightweightCharts..createChartcreateChart((
                        thisthis..containercontainer..querySelectorquerySelector(('#rsi-chart''#rsi-chart')),,  {{
                                widthwidth::  thisthis..containercontainer..clientWidthclientWidth,,
                                heightheight::  150150,,
                                layoutlayout::  {{
                                        backgroundColorbackgroundColor::  '#1a1a1a''#1a1a1a',,
                                        textColortextColor::  '#ffffff''#ffffff',,
                                }}
                        }}
                ));;
                
                // ðŸ”„ MACD Chart (separate pane) // ðŸ”„ MACD Chart (separate pane)
                thisthis..chartscharts..macdmacd  ==  LightweightCharts LightweightCharts..createChartcreateChart((
                        thisthis..containercontainer..querySelectorquerySelector(('#macd-chart''#macd-chart')),,  {{
                                widthwidth::  thisthis..containercontainer..clientWidthclientWidth,,  
                                heightheight::  150150,,
                                layoutlayout::  {{
                                        backgroundColorbackgroundColor::  '#1a1a1a''#1a1a1a',,
                                        textColortextColor::  '#ffffff''#ffffff',,
                                }}
                        }}
                ));;
                
                thisthis..setupSeriessetupSeries(());;
        }}
        
        setupSeriessetupSeries(())  {{
                // ðŸ•¯ Candlestick series // ðŸ•¯ Candlestick series
                thisthis..seriesseries  ==  {{
                        candlescandles::  thisthis..chartscharts..mainmain..addCandlestickSeries addCandlestickSeries(({{
                                upColorupColor::  '#4bffb5''#4bffb5',,
                                downColordownColor::  '#ff6b6b''#ff6b6b',,  
                                borderDownColorborderDownColor::  '#ff6b6b''#ff6b6b',,
                                borderUpColorborderUpColor::  '#4bffb5''#4bffb5',,
                                wickDownColorwickDownColor::  '#ff6b6b''#ff6b6b',,
                                wickUpColorwickUpColor::  '#4bffb5''#4bffb5',,
                        }})),,
                        
                        // ðŸ“Š EMA line// ðŸ“Š EMA line
                        emaema::  thisthis..chartscharts..mainmain..addLineSeriesaddLineSeries(({{
                                colorcolor::  '#ffaa00''#ffaa00',,
                                lineWidthlineWidth::  22,,
                                titletitle::  'EMA 20''EMA 20'
                        }})),,
                        
                        // ðŸ“ Bollinger Bands  // ðŸ“ Bollinger Bands  
                        bb_upperbb_upper::  thisthis..chartscharts..mainmain..addLineSeriesaddLineSeries(({{
                                colorcolor::  '#888888''#888888',,
                                lineWidthlineWidth::  11,,
                                titletitle::  'BB Upper''BB Upper'
                        }})),,
                        bb_lowerbb_lower::  thisthis..chartscharts..mainmain..addLineSeriesaddLineSeries(({{
                                colorcolor::  '#888888''#888888',,  
                                lineWidthlineWidth::  11,,
                                titletitle::  'BB Lower''BB Lower'
                        }})),,
                        
                        // ðŸ“ˆ RSI// ðŸ“ˆ RSI
                        rsirsi::  thisthis..chartscharts..rsirsi..addLineSeriesaddLineSeries(({{
                                colorcolor::  '#ff9500''#ff9500',,
                                lineWidthlineWidth::  22,,
                                titletitle::  'RSI 14''RSI 14'
                        }})),,
                        
                        // ðŸ”„ MACD// ðŸ”„ MACD
                        macdmacd::  thisthis..chartscharts..macdmacd..addLineSeriesaddLineSeries(({{
                                colorcolor::  '#00bcd4''#00bcd4',,
                                lineWidthlineWidth::  22,,  
                                titletitle::  'MACD''MACD'
                        }})),,
                        macd_signalmacd_signal::  thisthis..chartscharts..macdmacd..addLineSeriesaddLineSeries(({{
                                colorcolor::  '#ff5722''#ff5722',,
                                lineWidthlineWidth::  22,,
                                titletitle::  'Signal''Signal'
                        }}))
                }};;
                
                // Add RSI reference lines // Add RSI reference lines
                thisthis..chartscharts..rsirsi..addLineSeriesaddLineSeries(({{
                        colorcolor::  '#ff0000''#ff0000',,
                        lineWidthlineWidth::  11,,
                        priceLineVisiblepriceLineVisible::  falsefalse
                }}))..setDatasetData(([[{{timetime::  00,,  valuevalue::  7070}},,  {{timetime::  999999999 999999999,,  valuevalue::  7070}}]]));;
                
                thisthis..chartscharts..rsirsi..addLineSeriesaddLineSeries(({{
                        colorcolor::  '#00ff00''#00ff00',,  
                        lineWidthlineWidth::  11,,
                        priceLineVisiblepriceLineVisible::  falsefalse
                }}))..setDatasetData(([[{{timetime::  00,,  valuevalue::  3030}},,  {{timetime::  999999999 999999999,,  valuevalue::  3030}}]]));;
        }}
        
        updateCandleupdateCandle((datadata))  {{
                constconst time  time ==  MathMath..floorfloor((newnew  DateDate((datadata..timestamptimestamp))..getTimegetTime(())  //  10001000));;
                
                // ðŸ•¯ Update main candlestick // ðŸ•¯ Update main candlestick
                thisthis..seriesseries..candlescandles..updateupdate(({{
                        timetime:: time time,,
                        openopen:: data data..openopen,,
                        highhigh:: data data..highhigh,,  
                        lowlow:: data data..lowlow,,
                        closeclose:: data data..closeclose
                }}));;
                
                // ðŸ“Š Update indicators if enabled // ðŸ“Š Update indicators if enabled
                ifif  ((thisthis..indicatorsindicators..emaema  &&&& data data..indicatorsindicators..ema_20ema_20))  {{
                        thisthis..seriesseries..emaema..updateupdate(({{
                                timetime:: time time,,
                                valuevalue:: data data..indicatorsindicators..ema_20ema_20
                        }}));;
                }}
                
                ifif  ((thisthis..indicatorsindicators..rsirsi  &&&& data data..indicatorsindicators..rsi_14rsi_14))  {{
                        thisthis..seriesseries..rsirsi..updateupdate(({{
                                timetime:: time time,,
                                valuevalue:: data data..indicatorsindicators..rsi_14rsi_14
                        }}));;
                }}
                
                ifif  ((thisthis..indicatorsindicators..macdmacd  &&&& data data..indicatorsindicators..macdmacd))  {{
                        thisthis..seriesseries..macdmacd..updateupdate(({{
                                timetime:: time time,,
                                valuevalue:: data data..indicatorsindicators..macdmacd..macdmacd
                        }}));;
                        
                        thisthis..seriesseries..macd_signalmacd_signal..updateupdate(({{
                                timetime:: time time,,
                                valuevalue:: data data..indicatorsindicators..macdmacd..signalsignal
                        }}));;
                }}
                
                ifif  ((thisthis..indicatorsindicators..bollingerbollinger  &&&& data data..indicatorsindicators..bollingerbollinger))  {{
                        thisthis..seriesseries..bb_upperbb_upper..updateupdate(({{
                                timetime:: time time,,
                                valuevalue:: data data..indicatorsindicators..bollingerbollinger..upperupper
                        }}));;
                        
                        thisthis..seriesseries..bb_lowerbb_lower..updateupdate(({{
                                timetime:: time time,,
                                valuevalue:: data data..indicatorsindicators..bollingerbollinger..lowerlower    
                        }}));;
                }}
        }}
}}
// Initialize when DOM is ready // Initialize when DOM is ready
Phase 4: Implementation Checklist
âœ… Completed Features
 Real-time WebSocket data streaming
 Multi-pane chart layout
 Basic technical indicators (RSI, MACD, EMA)
 Time synchronization across panes
ðŸ”„ In Progress
 DuckDB data persistence
 Historical data loading
 Clean UI/UX implementation
 Symbol/interval switching
ðŸ“‹ Next Steps (Priority Order)
1. Immediate (Week 1)
 Implement DuckDB persistence layer
 Add historical data loading on chart startup
 Clean up UI layout and styling
 Add proper error handling and logging
2. Short Term (Week 2-3)
 Implement replay functionality
 Add indicator toggle controlsdocumentdocument..addEventListeneraddEventListener(('DOMContentLoaded' 'DOMContentLoaded',,  functionfunction(())  {{
        windowwindow..tradingCharttradingChart  ==  newnew  TradingChart TradingChart(('trading-container' 'trading-container'));;
}}));;


                                                                   ***********  Second Continuation ******************

# utils/error_handler.py
"""
ðŸš¨ COMPREHENSIVE ERROR HANDLING SYSTEM ðŸš¨
This module provides robust error handling, logging, and notification capabilities
for the TradingView platform. It includes DuckDB logging, email alerts, and
beautiful progress tracking.
"""

import logging
import time
import traceback
import sys
from datetime import datetime
from functools import wraps
from typing import Callable, Any, Optional, Dict
from pathlib import Path
import duckdb
import asyncio
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.text import Text
from tqdm import tqdm
import random

# Create console for rich output
console = Console()

class TradingViewErrorHandler:
    """
    ðŸ”§ MAIN ERROR HANDLING CLASS
    Manages all error handling, logging, and notification systems
    """
    
    def __init__(self, email_config: Optional[Dict] = None, telegram_config: Optional[Dict] = None):
        """Initialize error handler with optional notification configs"""
        print("ðŸ”¥ Initializing TradingView Error Handler...")
        
        self.email_config = email_config
        self.telegram_config = telegram_config
        self.error_count = 0
        self.last_error_time = None
        
        # Create necessary directories
        self.setup_directories()
        
        # Setup logging system
        self.setup_logging()
        
        # Setup DuckDB for error storage
        self.setup_error_database()
        
        print("âœ… Error Handler initialized successfully!")
    
    def setup_directories(self):
        """Create necessary directories for logs and data"""
        print("ðŸ“ Setting up directory structure...")
        
        directories = ['logs', 'data', 'data/errors']
        for directory in directories:
            Path(directory).mkdir(parents=True, exist_ok=True)
            print(f"   ðŸ“‚ Created/verified directory: {directory}")
    
    def setup_logging(self):
        """Configure comprehensive logging system"""
        print("ðŸ“ Configuring logging system...")
        
        # Create formatters
        detailed_formatter = logging.Formatter(
            '%(asctime)s | %(levelname)-8s | %(name)-20s | %(funcName)-15s:%(lineno)-4d | %(message)s'
        )
        
        simple_formatter = logging.Formatter(
            '%(asctime)s [%(levelname)s] %(message)s'
        )
        
        # Setup root logger
        self.logger = logging.getLogger('TradingView')
        self.logger.setLevel(logging.DEBUG)
        
        # File handler for detailed logs
        file_handler = logging.FileHandler('logs/trading_platform.log')
        file_handler.setLevel(logging.DEBUG)
        file_handler.setFormatter(detailed_formatter)
        
        # Console handler for important messages
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setLevel(logging.INFO)
        console_handler.setFormatter(simple_formatter)
        
        # Error file handler
        error_handler = logging.FileHandler('logs/errors.log')
        error_handler.setLevel(logging.ERROR)
        error_handler.setFormatter(detailed_formatter)
        
        # Add handlers
        self.logger.addHandler(file_handler)
        self.logger.addHandler(console_handler)
        self.logger.addHandler(error_handler)
        
        print("âœ… Logging system configured!")
    
    def setup_error_database(self):
        """Setup DuckDB database for storing errors and logs"""
        print("ðŸ—„ï¸ Setting up error database...")
        
        try:
            conn = duckdb.connect('data/errors/system_errors.duckdb')
            
            # Create errors table
            conn.execute("""
                CREATE TABLE IF NOT EXISTS system_errors (
                    id INTEGER PRIMARY KEY,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    error_type VARCHAR(100),
                    error_message TEXT,
                    stack_trace TEXT,
                    function_name VARCHAR(100),
                    file_name VARCHAR(200),
                    line_number INTEGER,
                    severity VARCHAR(20),
                    component VARCHAR(50),
                    resolved BOOLEAN DEFAULT FALSE,
                    resolution_notes TEXT
                )
            """)
            
            # Create performance logs table
            conn.execute("""
                CREATE TABLE IF NOT EXISTS performance_logs (
                    id INTEGER PRIMARY KEY,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    operation VARCHAR(100),
                    duration_ms DOUBLE,
                    memory_usage_mb DOUBLE,
                    cpu_usage_percent DOUBLE,
                    details TEXT
                )
            """)
            
            # Create system events table
            conn.execute("""
                CREATE TABLE IF NOT EXISTS system_events (
                    id INTEGER PRIMARY KEY,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    event_type VARCHAR(50),
                    event_description TEXT,
                    component VARCHAR(50),
                    user_id VARCHAR(50),
                    session_id VARCHAR(100),
                    additional_data TEXT
                )
            """)
            
            conn.close()
            print("âœ… Error database setup complete!")
            
        except Exception as e:
            print(f"âŒ Error setting up database: {e}")
            self.logger.error(f"Database setup failed: {e}")
    
    def log_error_to_database(self, error_info: Dict):
        """Store error information in DuckDB"""
        try:
            conn = duckdb.connect('data/errors/system_errors.duckdb')
            conn.execute("""
                INSERT INTO system_errors 
                (error_type, error_message, stack_trace, function_name, file_name, line_number, severity, component)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                error_info.get('error_type', 'Unknown'),
                error_info.get('error_message', ''),
                error_info.get('stack_trace', ''),
                error_info.get('function_name', ''),
                error_info.get('file_name', ''),
                error_info.get('line_number', 0),
                error_info.get('severity', 'ERROR'),
                error_info.get('component', 'SYSTEM')
            ))
            conn.close()
        except Exception as e:
            self.logger.error(f"Failed to log error to database: {e}")
    
    def handle_exception(self, exception: Exception, context: str = ""):
        """Handle an exception with comprehensive logging and notification"""
        print(f"ðŸš¨ EXCEPTION CAUGHT: {type(exception).__name__}")
        
        # Get exception details
        error_info = {
            'error_type': type(exception).__name__,
            'error_message': str(exception),
            'stack_trace': traceback.format_exc(),
            'context': context,
            'timestamp': datetime.now(),
            'function_name': sys._getframe(1).f_code.co_name,
            'file_name': sys._getframe(1).f_code.co_filename,
            'line_number': sys._getframe(1).f_lineno,
            'severity': 'ERROR',
            'component': 'WEBSOCKET' if 'websocket' in context.lower() else 'SYSTEM'
        }
        
        # Log to file and database
        self.logger.error(f"Error in {context}: {exception}")
        self.log_error_to_database(error_info)
        
        # Display rich error panel
        self.display_error_panel(error_info)
        
        # Update error counter
        self.error_count += 1
        self.last_error_time = datetime.now()
        
        # Send notifications (if configured)
        # self.send_error_notification(error_info)  # Uncomment when ready
        
        return error_info
    
    def display_error_panel(self, error_info: Dict):
        """Display beautiful error information using Rich"""
        error_text = Text()
        error_text.append("ðŸš¨ ERROR DETECTED ðŸš¨\n", style="bold red")
        error_text.append(f"Type: {error_info['error_type']}\n", style="bold yellow")
        error_text.append(f"Message: {error_info['error_message']}\n", style="white")
        error_text.append(f"Function: {error_info['function_name']}\n", style="blue")
        error_text.append(f"File: {error_info['file_name']}:{error_info['line_number']}\n", style="green")
        error_text.append(f"Time: {error_info['timestamp']}\n", style="magenta")
        
        panel = Panel(
            error_text,
            title="[bold red]SYSTEM ERROR[/bold red]",
            border_style="red",
            padding=(1, 2)
        )
        
        console.print(panel)
    
    def send_error_notification(self, error_info: Dict):
        """Send error notifications via email and telegram (when configured)"""
        print("ðŸ“§ Preparing error notifications...")
        
        # Email notification (commented out until configured)
        """
        if self.email_config:
            try:
                yag = yagmail.SMTP(
                    user=self.email_config['user'],
                    password=self.email_config['password']
                )
                
                subject = f"ðŸš¨ TradingView Error Alert: {error_info['error_type']}"
                body = f'''
                Error Details:
                - Type: {error_info['error_type']}
                - Message: {error_info['error_message']}
                - Function: {error_info['function_name']}
                - File: {error_info['file_name']}:{error_info['line_number']}
                - Time: {error_info['timestamp']}
                - Context: {error_info['context']}
                
                Stack Trace:
                {error_info['stack_trace']}
                '''
                
                yag.send(
                    to=self.email_config['recipients'],
                    subject=subject,
                    contents=body
                )
                print("âœ… Email notification sent!")
                
            except Exception as e:
                print(f"âŒ Failed to send email notification: {e}")
        """
        
        # Telegram notification (commented out until configured)
        """
        if self.telegram_config:
            try:
                import telegram
                bot = telegram.Bot(token=self.telegram_config['token'])
                
                message = f'''
ðŸš¨ *TradingView Error Alert*
                
*Type:* `{error_info['error_type']}`
*Message:* `{error_info['error_message']}`
*Function:* `{error_info['function_name']}`
*Time:* `{error_info['timestamp']}`
                '''
                
                bot.send_message(
                    chat_id=self.telegram_config['chat_id'],
                    text=message,
                    parse_mode='Markdown'
                )
                print("âœ… Telegram notification sent!")
                
            except Exception as e:
                print(f"âŒ Failed to send telegram notification: {e}")
        """


class CustomProgressBar:
    """
    ðŸŽ¨ BEAUTIFUL PROGRESS BAR SYSTEM
    Creates animated, colorful progress bars with various styles
    """
    
    def __init__(self):
        """Initialize progress bar with different styles and colors"""
        print("ðŸŽ¨ Initializing Custom Progress Bar System...")
        
        # Different bar styles for variety
        self.bar_styles = [
            '[|||||| {}]',   # Pipe style
            '[â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ {}]',   # Block style  
            '[â˜…â˜…â˜…â˜…â˜… {}]',   # Star style
            '[â—â—â—â—â— {}]',   # Circle style
            '[â™¦â™¦â™¦â™¦â™¦ {}]',   # Diamond style
            '[â–“â–“â–“â–“â–“ {}]',   # Shade style
            '[â–€â–€â–€â–€â–€ {}]',   # Top block style
        ]
        
        # Color progression for different completion percentages
        self.color_progression = [
            'red',      # 0-20%
            'yellow',   # 20-40%
            'blue',     # 40-60%
            'green',    # 60-80%
            'magenta'   # 80-100%
        ]
        
        print("âœ… Progress Bar System ready!")
    
    def create_processing_bar(self, total: int, description: str = "Processing", delay: float = 0.1):
        """Create an animated processing bar with random style"""
        print(f"ðŸ”„ Starting progress: {description}")
        
        # Choose random style
        style = random.choice(self.bar_styles)
        current_color_index = 0
        
        # Custom format function
        def format_bar(n, total, elapsed, rate, remaining):
            # Calculate percentage
            percentage = (n / total) * 100 if total > 0 else 0
            
            # Determine color based on percentage
            color_index = min(int(percentage // 20), len(self.color_progression) - 1)
            color = self.color_progression[color_index]
            
            # Create custom bar display
            filled_length = int((n / total) * 30) if total > 0 else 0
            bar_display = 'â–ˆ' * filled_length + 'â–‘' * (30 - filled_length)
            
            return f'[{color}]{bar_display}[/{color}] {percentage:.1f}%'
        
        # Create tqdm progress bar
        with tqdm(
            total=total,
            desc=description,
            bar_format='{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt} [{elapsed}<{remaining}]',
            ascii=False,
            ncols=80,
            colour='green'
        ) as pbar:
            
            for i in range(total):
                # Simulate work
                time.sleep(delay)
                
                # Update progress
                pbar.update(1)
                
                # Change color every 20%
                if i > 0 and i % (total // 5) == 0:
                    current_color_index = min(current_color_index + 1, len(self.color_progression) - 1)
                    pbar.colour = self.color_progression[current_color_index]
        
        print(f"âœ… {description} completed!")
    
    def create_data_loading_bar(self, items: list, description: str = "Loading Data"):
        """Create progress bar for loading data items"""
        print(f"ðŸ“Š Loading data: {description}")
        
        results = []
        
        with tqdm(
            items,
            desc=description,
            bar_format='{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt} items',
            colour='blue'
        ) as pbar:
            
            for item in pbar:
                # Process each item (simulate processing time)
                time.sleep(0.05)  # Faster for data loading
                
                # Update description with current item info
                pbar.set_description(f"{description} - Processing: {str(item)[:20]}...")
                
                results.append(item)  # Store processed item
        
        print(f"âœ… Loaded {len(results)} items successfully!")
        return results


# Decorator for automatic error handling
def handle_errors(retry_count: int = 3, delay: float = 5.0, component: str = "SYSTEM"):
    """
    ðŸ›¡ï¸ DECORATOR FOR AUTOMATIC ERROR HANDLING
    Automatically catches and handles errors with retry logic
    """
    def decorator(func: Callable) -> Callable:
        @wr

****************************** Third Continuation ******************************
             # TradingView-like Platform: Continuation Implementation Guide

## Phase 1: DuckDB Integration & Historical Data Storage (Priority 1)

### 1.1 Database Schema Setup
**File**: `apps/database/duckdb_manager.py`

```python
"""
DuckDB Manager for OHLC and Indicators Storage
Implements columnar storage for blazing-fast queries
"""
import duckdb
import polars as pl
from pathlib import Path
import logging
from datetime import datetime
from typing import Dict, List, Optional
import asyncio

class DuckDBManager:
    def __init__(self, base_path: str = "data/duckdb"):
        """Initialize DuckDB manager with base storage path"""
        self.base_path = Path(base_path)
        self.base_path.mkdir(parents=True, exist_ok=True)
        self.connections = {}  # Cache connections per symbol-interval
        self.logger = logging.getLogger(__name__)
        
    def get_db_path(self, symbol: str, interval: str) -> Path:
        """Generate database path for symbol-interval combination"""
        filename = f"{symbol}_{interval}.duckdb"
        return self.base_path / filename
    
    async def initialize_tables(self, symbol: str, interval: str):
        """Create tables if they don't exist"""
        db_path = self.get_db_path(symbol, interval)
        
        # Connect to DuckDB
        conn = duckdb.connect(str(db_path))
        
        # Create OHLC + Indicators table
        conn.execute("""
            CREATE TABLE IF NOT EXISTS candles (
                timestamp TIMESTAMP PRIMARY KEY,
                symbol VARCHAR NOT NULL,
                interval VARCHAR NOT NULL,
                open DOUBLE NOT NULL,
                high DOUBLE NOT NULL,
                low DOUBLE NOT NULL,
                close DOUBLE NOT NULL,
                volume DOUBLE NOT NULL,
                -- Technical Indicators
                ema_9 DOUBLE,
                ema_21 DOUBLE,
                rsi_14 DOUBLE,
                macd_line DOUBLE,
                macd_signal DOUBLE,
                macd_histogram DOUBLE,
                bb_upper DOUBLE,
                bb_middle DOUBLE,
                bb_lower DOUBLE,
                -- Metadata
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
            )
        """)
        
        # Create indexes for fast queries
        conn.execute("CREATE INDEX IF NOT EXISTS idx_timestamp ON candles(timestamp)")
        conn.execute("CREATE INDEX IF NOT EXISTS idx_symbol_interval ON candles(symbol, interval)")
        
        self.connections[f"{symbol}_{interval}"] = conn
        self.logger.info(f"âœ… DuckDB initialized for {symbol}_{interval}")
        
    async def insert_candle(self, symbol: str, interval: str, candle_data: Dict):
        """Insert single candle with indicators"""
        conn_key = f"{symbol}_{interval}"
        if conn_key not in self.connections:
            await self.initialize_tables(symbol, interval)
            
        conn = self.connections[conn_key]
        
        # Upsert candle data
        conn.execute("""
            INSERT OR REPLACE INTO candles 
            (timestamp, symbol, interval, open, high, low, close, volume,
             ema_9, ema_21, rsi_14, macd_line, macd_signal, macd_histogram,
             bb_upper, bb_middle, bb_lower)
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        """, [
            candle_data['timestamp'],
            symbol, interval,
            candle_data['open'], candle_data['high'], 
            candle_data['low'], candle_data['close'], candle_data['volume'],
            candle_data.get('ema_9'), candle_data.get('ema_21'),
            candle_data.get('rsi_14'),
            candle_data.get('macd_line'), candle_data.get('macd_signal'), 
            candle_data.get('macd_histogram'),
            candle_data.get('bb_upper'), candle_data.get('bb_middle'), 
            candle_data.get('bb_lower')
        ])
        
        self.logger.debug(f"ðŸ“Š Inserted candle for {symbol}_{interval} at {candle_data['timestamp']}")
    
    async def get_historical_candles(self, symbol: str, interval: str, limit: int = 300) -> pl.DataFrame:
        """Fetch last N candles using Polars for blazing speed"""
        conn_key = f"{symbol}_{interval}"
        if conn_key not in self.connections:
            await self.initialize_tables(symbol, interval)
            
        conn = self.connections[conn_key]
        
        # Query using Polars for speed
        query = f"""
            SELECT * FROM candles 
            WHERE symbol = '{symbol}' AND interval = '{interval}'
            ORDER BY timestamp DESC 
            LIMIT {limit}
        """
        
        # Convert to Polars DataFrame
        df = pl.read_database(query, conn)
        self.logger.info(f"ðŸ“ˆ Retrieved {len(df)} historical candles for {symbol}_{interval}")
        
        return df.sort("timestamp")  # Ensure chronological order
```

### 1.2 Historical Data Loader
**File**: `apps/data/historical_loader.py`

```python
"""
Historical Data Loader from Binance
Populates DuckDB with historical candles for chart initialization
"""
import aiohttp
import asyncio
from datetime import datetime, timedelta
import pandas as pd
from typing import List, Dict
import logging
from tqdm.asyncio import tqdm
import time

class HistoricalDataLoader:
    def __init__(self, duckdb_manager):
        self.duckdb_manager = duckdb_manager
        self.logger = logging.getLogger(__name__)
        self.base_url = "https://api.binance.com/api/v3/klines"
        
    async def fetch_historical_klines(self, symbol: str, interval: str, limit: int = 1000) -> List[Dict]:
        """Fetch historical klines from Binance API"""
        params = {
            'symbol': symbol,
            'interval': interval,
            'limit': limit
        }
        
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(self.base_url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        
                        # Convert to OHLC format
                        candles = []
                        for kline in data:
                            candle = {
                                'timestamp': datetime.fromtimestamp(kline[0] / 1000),
                                'open': float(kline[1]),
                                'high': float(kline[2]),
                                'low': float(kline[3]),
                                'close': float(kline[4]),
                                'volume': float(kline[5])
                            }
                            candles.append(candle)
                            
                        self.logger.info(f"ðŸ“¥ Fetched {len(candles)} historical candles for {symbol}_{interval}")
                        return candles
                        
            except Exception as e:
                self.logger.error(f"âŒ Error fetching historical data: {e}")
                return []
                
    async def calculate_indicators_batch(self, candles: List[Dict]) -> List[Dict]:
        """Calculate all indicators for historical candles"""
        # Convert to pandas for indicator calculation
        df = pd.DataFrame(candles)
        
        # Calculate indicators (reuse your existing indicator functions)
        # EMA calculations
        df['ema_9'] = df['close'].ewm(span=9).mean()
        df['ema_21'] = df['close'].ewm(span=21).mean()
        
        # RSI calculation
        delta = df['close'].diff()
        gain = (delta.where(delta > 0, 0)).ewm(span=14).mean()
        loss = (-delta.where(delta < 0, 0)).ewm(span=14).mean()
        df['rsi_14'] = 100 - (100 / (1 + gain / loss))
        
        # MACD calculation
        exp1 = df['close'].ewm(span=12).mean()
        exp2 = df['close'].ewm(span=26).mean()
        df['macd_line'] = exp1 - exp2
        df['macd_signal'] = df['macd_line'].ewm(span=9).mean()
        df['macd_histogram'] = df['macd_line'] - df['macd_signal']
        
        # Bollinger Bands
        df['bb_middle'] = df['close'].rolling(window=20).mean()
        bb_std = df['close'].rolling(window=20).std()
        df['bb_upper'] = df['bb_middle'] + (bb_std * 2)
        df['bb_lower'] = df['bb_middle'] - (bb_std * 2)
        
        return df.to_dict('records')
        
    async def populate_historical_data(self, symbols: List[str], intervals: List[str]):
        """Populate DuckDB with historical data for all symbol-interval combinations"""
        total_combinations = len(symbols) * len(intervals)
        
        # Create beautiful progress bar
        progress_chars = ['â–ˆ', 'â–“', 'â–’', 'â–‘', 'â—†', 'â—‡', 'â—', 'â—‹', 'â˜…', 'â˜†']
        colors = ['red', 'yellow', 'green', 'cyan', 'magenta']
        
        with tqdm(total=total_combinations, desc="ðŸš€ Loading Historical Data", 
                 bar_format='{desc}: {percentage:3.0f}%|{bar}| {n_fmt}/{total_fmt}') as pbar:
            
            for symbol in symbols:
                for interval in intervals:
                    try:
                        self.logger.info(f"ðŸ“Š Processing {symbol}_{interval}...")
                        
                        # Fetch historical data
                        candles = await self.fetch_historical_klines(symbol, interval, 1000)
                        
                        if candles:
                            # Calculate indicators
                            candles_with_indicators = await self.calculate_indicators_batch(candles)
                            
                            # Store in DuckDB
                            for candle in candles_with_indicators:
                                await self.duckdb_manager.insert_candle(symbol, interval, candle)
                                
                            self.logger.info(f"âœ… Stored {len(candles_with_indicators)} candles for {symbol}_{interval}")
                        
                        pbar.update(1)
                        
                        # Rate limiting
                        await asyncio.sleep(0.1)
                        
                    except Exception as e:
                        self.logger.error(f"âŒ Error processing {symbol}_{interval}: {e}")
                        pbar.update(1)
                        continue
```

## Phase 2: Enhanced WebSocket with Historical Loading

### 2.1 Enhanced WebSocket Manager
**File**: `apps/websocket/enhanced_ws_manager.py`

```python
"""
Enhanced WebSocket Manager with Historical Data Integration
Loads historical candles first, then streams live data
"""
import asyncio
import websockets
import json
from datetime import datetime
import logging
from typing import Dict, List, Callable
from apps.database.duckdb_manager import DuckDBManager
from apps.data.historical_loader import HistoricalDataLoader

class EnhancedWebSocketManager:
    def __init__(self, on_candle_callback: Callable):
        self.on_candle_callback = on_candle_callback
        self.duckdb_manager = DuckDBManager()
        self.historical_loader = HistoricalDataLoader(self.duckdb_manager)
        self.current_symbol = None
        self.current_interval = None
        self.websocket = None
        self.logger = logging.getLogger(__name__)
        self.is_connected = False
        
    async def initialize_chart_with_history(self, symbol: str, interval: str):
        """Load historical data first, then start live streaming"""
        self.logger.info(f"ðŸ”„ Initializing chart for {symbol}_{interval}")
        
        try:
            # 1. Load historical candles from DuckDB
            historical_df = await self.duckdb_manager.get_historical_candles(
                symbol, interval, limit=300
            )
            
            # 2. If no historical data, fetch from Binance API
            if len(historical_df) == 0:
                self.logger.warning(f"ðŸ“­ No historical data found, fetching from Binance...")
                await self.historical_loader.populate_historical_data([symbol], [interval])
                historical_df = await self.duckdb_manager.get_historical_candles(
                    symbol, interval, limit=300
                )
            
            # 3. Stream historical candles to frontend (fast replay)
            self.logger.info(f"ðŸ“ˆ Streaming {len(historical_df)} historical candles...")
            for row in historical_df.iter_rows(named=True):
                candle_data = {
                    'timestamp': row['timestamp'],
                    'symbol': row['symbol'],
                    'interval': row['interval'],
                    'open': row['open'],
                    'high': row['high'],
                    'low': row['low'],
                    'close': row['close'],
                    'volume': row['volume'],
                    'indicators': {
                        'ema_9': row['ema_9'],
                        'ema_21': row['ema_21'],
                        'rsi_14': row['rsi_14'],
                        'macd_line': row['macd_line'],
                        'macd_signal': row['macd_signal'],
                        'macd_histogram': row['macd_histogram'],
                        'bb_upper': row['bb_upper'],
                        'bb_middle': row['bb_middle'],
                        'bb_lower': row['bb_lower']
                    },
                    'is_historical': True
                }
                
                # Send to frontend
                await self.on_candle_callback(candle_data)
                
                # Small delay for smooth loading animation
                await asyncio.sleep(0.01)
            
            self.logger.info(f"âœ… Historical data loaded, starting live stream...")
            
            # 4. Start live WebSocket connection
            await self.start_live_stream(symbol, interval)
            
        except Exception as e:
            self.logger.error(f"âŒ Error initializing chart: {e}")
            
    async def start_live_stream(self, symbol: str, interval: str):
        """Start live WebSocket streaming from Binance"""
        self.current_symbol = symbol
        self.current_interval = interval
        
        stream_name = f"{symbol.lower()}@kline_{interval}"
        ws_url = f"wss://stream.binance.com:9443/ws/{stream_name}"
        
        try:
            self.websocket = await websockets.connect(ws_url)
            self.is_connected = True
            self.logger.info(f"ðŸ”— Connected to live stream: {stream_name}")
            
            async for message in self.websocket:
                if not self.is_connected:
                    break
                    
                data = json.loads(message)
                await self.process_live_candle(data)
                
        except Exception as e:
            self.logger.error(f"âŒ WebSocket error: {e}")
            self.is_connected = False
            
    async def process_live_candle(self, data: Dict):
        """Process live candle data and store in DuckDB"""
        try:
            kline = data['k']
            
            candle_data = {
                'timestamp': datetime.fromtimestamp(kline['t'] / 1000),
                'symbol': kline['s'],
                'interval': kline['i'],
                'open': float(kline['o']),
                'high': float(kline['h']),
                'low': float(kline['l']),
                'close': float(kline['c']),
                'volume': float(kline['v']),
                'is_historical': False
            }
            
            # Calculate indicators (implement your existing logic)
            candle_data['indicators'] = await self.calculate_live_indicators(candle_data)
            
            # Store in DuckDB
            await self.duckdb_manager.insert_candle(
                candle_data['symbol'], 
                candle_data['interval'], 
                {**candle_data, **candle_data['indicators']}
            )
            
            # Send to frontend
            await self.on_candle_callback(candle_data)
            
        except Exception as e:
            self.logger.error(f"âŒ Error processing live candle: {e}")
            
    async def switch_symbol_interval(self, symbol: str, interval: str):
        """Clean switch to new symbol/interval"""
        self.logger.info(f"ðŸ”„ Switching to {symbol}_{interval}")
        
        # 1. Close existing connection
        if self.websocket and self.is_connected:
            await self.websocket.close()
            self.is_connected = False
            
        # 2. Initialize new chart with history
        await self.initialize_chart_with_history(symbol, interval)
```

## Phase 3: Symbol & Interval Selector UI

### 3.1 Enhanced Frontend Controls
**File**: `templates/trading/chart.html` (additions)

```html 
<!-- Enhanced Symbol & Interval Selector -->
<div class="control-panel" style="position: fixed; top: 20px; left: 20px; z-index: 1000; 
     background: rgba(255,255,255,0.95); padding: 15px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15);">
     
    <!-- Symbol Selector -->
    <div class="selector-group">
        <label for="symbolSelector">ðŸ“Š Symbol:</label>
        <select id="symbolSelector" class="form-control" style="width: 120px; display: inline-block;">
            <option value="BTCUSDT">BTC/USDT</option>
            <option value="ETHUSDT">ETH/USDT</option>
            <option value="BNBUSDT">BNB/USDT</option>
            <option value="ADAUSDT">ADA/USDT</option>
            <option value="SOLUSDT">SOL/USDT</option>
        </select>
    </div>
    
    <!-- Interval Selector -->
    <div class="selector-group" style="margin-left: 10px;">
        <label for="intervalSelector">â±ï¸ Interval:</label>
        <select id="intervalSelector" class="form-control" style="width: 80px; display: inline-block;">
            <!-- Ticks -->
            <optgroup label="Ticks">
                <option value="1tick">1 Tick</option>
                <option value="10tick">10 Ticks</option>
                <option value="100tick">100 Ticks</option>
                <option value="1000tick">1000 Ticks</option>
            </optgroup>
            
            <!-- Seconds -->
            <optgroup label="Seconds">
                <option value="1s">1s</option>
                <option value="3s">3s</option>
                <option value="5s">5s</option>
                <option value="15s">15s</option>
                <option value="30s">30s</option>
            </optgroup>
            
            <!-- Minutes -->
            <optgroup label="Minutes">
                <option value="1m" selected>1m</option>
                <option value="3m">3m</option>
                <option value="5m">5m</option>
                <option value="15m">15m</option>
                <option value="30m">30m</option>
                <option value="45m">45m</option>
            </optgroup>
            
            <!-- Hours -->
            <optgroup label="Hours">
                <option value="1h">1h</option>
                <option value="2h">2h</option>
                <option value="3h">3h</option>
                <option value="4h">4h</option>
                <option value="6h">6h</option>
                <option value="12h">12h</option>
            </optgroup>
            
            <!-- Days & Beyond -->
            <optgroup label="Days+">
                <option value="1d">1D</option>
                <option value="1w">1W</option>
                <option value="1M">1M</option>
                <option value="3M">3M</option>
                <option value="6M">6M</option>
                <option value="1y">1Y</option>
            </optgroup>
            
            <!-- Ranges -->
            <optgroup label="Ranges">
                <option value="1R">1R</option>
                <option value="10R">10R</option>
                <option value="100R">100R</option>
                <option value="1000R">1000R</option>
            </optgroup>
        </select>
    </div>
    
    <!-- Apply Button -->
    <button id="applySelection" class="btn btn-primary" style="margin-left: 10px;">
        ðŸš€ Apply
    </button>
    
    <!-- Loading Indicator -->
    <div id="loadingIndicator" style="display: none; margin-left: 10px;">
        <div class="spinner-border spinner-border-sm" role="status">
            <span class="sr-only">Loading...</span>
        </div>
        <span style="margin-left: 5px;">Loading...</span>
    </div>
</div>

<!-- Enhanced JavaScript -->
<script>
document.addEventListener('DOMContentLoaded', function() {
    const symbolSelector = document.getElementById('symbolSelector');
    const intervalSelector = document.getElementById('intervalSelector');
    const applyButton = document.getElementById('applySelection');
    const loadingIndicator = document.getElementById('loadingIndicator');
    
    // Apply selection
    applyButton.addEventListener('click', async function() {
        const symbol = symbolSelector.value;
        const interval = intervalSelector.value;
        
        console.log(`ðŸ”„ Switching to ${symbol} ${interval}`);
        
        // Show loading
        loadingIndicator.style.display = 'inline-block';
        applyButton.disabled = true;
        
        try {
            // Send switch request to backend
            await fetch('/api/switch-symbol-interval/', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'X-CSRFToken': getCookie('csrftoken')
                },
                body: JSON.stringify({
                    symbol: symbol,
                    interval: interval
                })
            });
            
            // Clear existing chart data
            if (window.chartManager) {
                window.chartManager.clearAllCharts();
            }
            
        } catch (error) {
            console.error('âŒ Error switching symbol/interval:', error);
        } finally {
            // Hide loading
            loadingIndicator.style.display = 'none';
            applyButton.disabled = false;
        }
    });
    
    // Save preferences to localStorage
    function savePreferences() {
        localStorage.setItem('tradingPreferences', JSON.stringify({
            symbol: symbolSelector.value,
            interval: intervalSelector.value,
            timestamp: Date.now()
        }));
    }
    
    // Load preferences from localStorage
    function loadPreferences() {
        const saved = localStorage.getItem('tradingPreferences');
        if (saved) {
            const prefs = JSON.parse(saved);
            symbolSelector.value = prefs.symbol || 'BTCUSDT';
            intervalSelector.value = prefs.interval || '1m';
        }
    }
    
    // Auto-save preferences
    symbolSelector.addEventListener('change', savePreferences);
    intervalSelector.addEventListener('change', savePreferences);
    
    // Load saved preferences on page load
    loadPreferences();
});

function getCookie(name) {
    let cookieValue = null;
    if (document.cookie && document.cookie !== '') {
        const cookies = document.cookie.split(';');
        for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === (name + '=')) {
                cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                break;
            }
        }
    }
    return cookieValue;
}
</script>
```

## Phase 4: Indicator Toggle UI & Persistence

### 4.1 Indicator Control Panel
**File**: `templates/trading/indicator_controls.html`

```html
<!-- Indicator Control Panel --
<div class="indicator-panel" style="position: fixed; top: 20px; right: 20px; z-index: 1000;
     background: rgba(42, 42, 42, 0.95); color: white; padding: 20px; border-radius: 8px; 
     box-shadow: 0 4px 12px rgba(0,0,0,0.3); min-width: 250px;">
     
    <h5 style="margin-bottom: 15px; color: #00d4aa;">ðŸ§© Indicators</h5>
    
    <!-- Main Chart Indicators --
    <div class="indicator-group">
        <h6 style="color: #ccc; margin-bottom: 10px;">ðŸ“ˆ Main Chart</h6>
        
        <!-- EMA Controls --
        <div class="indicator-item" style="margin-bottom: 10px;">
            <label class="switch" style="display: flex; align-items: center;">
                <input type="checkbox" id="emaToggle" checked>
                <span class="slider round" style="margin-right: 10px;"></span>
                <span>EMA (9, 21)</span>
            </label>
            <div class="indicator-params" id="emaParams" style="margin-left: 25px; margin-top: 5px;">
                <input type="number" id="emaFast" value="9" min="1" max="50" style="width: 50px; margin-right: 5px;">
                <input type="number" id="emaSlow" value="21" min="1" max="100" style="width: 50px;">
            </div>
        </div>
        
        <!-- Bollinger Bands --
        <div class="indicator-item" style="margin-bottom: 10px;">
            <label class="switch" style="display: flex; align-items: center;">
                <input type="checkbox" id="bbToggle" checked>
                <span class="slider round" style="margin-right: 10px;"></span>
                <span>Bollinger Bands</span>
            </label>
            <div class="indicator-params" id="bbParams" style="margin-left: 25px; margin-top: 5px;">
                <label style="font-size: 11px;">Period:</label>
                <input type="number" id="bbPeriod" value="20" min="5" max="50" style="width: 50px; margin-right: 10px;">
                <label style="font-size: 11px;">StdDev:</label>
                <input type="number" id="bbStdDev" value="2" min="1" max="5" step="0.1" style="width: 50px;">
            </div>
        </div>
    </div>
    
    <!-- Oscillator Indicators --
    <div class="indicator-group" style="margin-top: 15px;">
        <h6 style="color: #ccc; margin-bottom: 10px;">ðŸ“Š Oscillators</h6>
        
        <!-- RSI --
        <div class="indicator-item" style="margin-bottom: 10px;">
            <label class="switch" style="display: flex; align-items: center;">
                <input type="checkbox" id="rsiToggle" checked>
                <span class="slider round" style="margin-right: 10px;"></span>
                <span>RSI</span>
            </label>
            <div class="indicator-params" id="rsiParams" style="margin-left: 25px; margin-top: 5px;">
                <label style="font-size: 11px;">Period:</label>
                <input type="number" id="rsiPeriod" value="14" min="2" max="50" style="width: 50px;">
            </div>
        </div>
        
        <!-- MACD --
        <div class="indicator-item" style="margin-bottom: 10px;">
            <label class="switch" style="display: flex; align-items: center;">
                <input type="checkbox" id="macdToggle" checked>
                <span class="slider round" style="margin-right: 10px;"></span>
                <span>MACD</span>
            </label>
            <div class="indicator-params" id="macdParams" style="margin-left: 25px; margin-top: 5px;">
                <input type="number" id="macdFast" value="12" min="1" max="50" style="width: 40px; margin-right: 3px;">
                <input type="number" id="macdSlow" value="26" min="1" max="100" style="width: 40px; margin-right: 3px;">
                <input type="number" id="macdSignal" value="9" min="1" max="30" style="width: 40px;">
            </div>
        </div>
        
        <!-- Stochastic --
        <div class="indicator-item" style="margin-bottom: 10px;">
            <label class="switch" style="display: flex; align-items: center;">
                <input type="checkbox" id="stochToggle">
                <span class="slider round" style="margin-right: 10px;"></span>
                <span>Stochastic</span>
            </label>
            <div class="indicator-params" id="stochParams" style="margin-left: 25px; margin-top: 5px; display: none;">
                <label style="font-size: 11px;">%K:</label>
                <input type="number" i
